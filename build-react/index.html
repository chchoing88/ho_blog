<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/ho_blog/component---src-layouts-index-js-60e98b905b7a1c56256e.js" as="script"/><link rel="preload" href="/ho_blog/component---src-templates-blog-post-js-dabe65ee189101b630a0.js" as="script"/><link rel="preload" href="/ho_blog/path---build-react-8fe160cba69ecb4070e4.js" as="script"/><link rel="preload" href="/ho_blog/app-00a132d46dd380b9cb63.js" as="script"/><link rel="preload" href="/ho_blog/commons-241c3561f1c9cf4619a9.js" as="script"/><style id="glamor-styles"></style><script id="glamor-ids">
        // <![CDATA[
        window._glamor = []
        // ]]>
        </script><link rel="alternate" type="application/rss+xml" href="/ho_blog/rss.xml"/><title data-react-helmet="true">build-react | Merlin Tec Blog</title><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:106.25%/1.53 'Source Sans Pro',sans-serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:'Source Sans Pro',sans-serif;font-weight:400;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;color:inherit;font-family:'Merriweather',serif;font-weight:700;text-rendering:optimizeLegibility;font-size:2rem;line-height:2.295rem;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;color:inherit;font-family:'Merriweather',serif;font-weight:700;text-rendering:optimizeLegibility;font-size:1.51572rem;line-height:2.295rem;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;color:inherit;font-family:'Merriweather',serif;font-weight:700;text-rendering:optimizeLegibility;font-size:1.1487rem;line-height:1.53rem;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;color:inherit;font-family:'Merriweather',serif;font-weight:700;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.53rem;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;color:inherit;font-family:'Merriweather',serif;font-weight:700;text-rendering:optimizeLegibility;font-size:0.917rem;line-height:1.53rem;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;color:inherit;font-family:Source Sans Pro,sans-serif;font-weight:400;text-rendering:optimizeLegibility;font-size:0.8409rem;line-height:1.53rem;text-transform:uppercase;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}ul{margin-left:1.53rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.53rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;font-size:0.85rem;line-height:1.42;background:hsla(0,0%,0%,0.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.53rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;font-size:1rem;line-height:1.53rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}blockquote{margin-left:1.53rem;margin-right:1.53rem;margin-top:0;padding-bottom:0.51rem;padding-left:1.02rem;padding-right:1.02rem;padding-top:0.51rem;margin-bottom:1.53rem;font-size:1.18921rem;line-height:1.53rem;border-left:0.255rem solid;border-color:hsla(0,0%,0%,0.07);}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.53rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.53rem;}b{font-weight:700;}strong{font-weight:700;}dt{font-weight:700;}th{font-weight:700;}li{margin-bottom:calc(1.53rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.53rem;margin-bottom:calc(1.53rem / 2);margin-top:calc(1.53rem / 2);}li > ul{margin-left:1.53rem;margin-bottom:calc(1.53rem / 2);margin-top:calc(1.53rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.53rem / 2);}code{font-size:0.85rem;line-height:1.53rem;}kbd{font-size:0.85rem;line-height:1.53rem;}samp{font-size:0.85rem;line-height:1.53rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:1.02rem;padding-right:1.02rem;padding-top:0.765rem;padding-bottom:calc(0.765rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}tt,code{background-color:hsla(0,0%,0%,0.04);border-radius:3px;font-family:"SFMono-Regular", Consolas,"Roboto Mono","Droid Sans Mono","Liberation Mono",Menlo,Courier,monospace;padding:0;padding-top:0.2em;padding-bottom:0.2em;}pre code{background:none;line-height:1.42;}code:before,code:after,tt:before,tt:after{letter-spacing:-0.2em;content:" ";}pre code:before,pre code:after,pre tt:before,pre tt:after{content:none;}a{color:#0071bc;text-decoration:none;}a:visited{color:#4c2c92;}blockquote > :last-child{margin-bottom:0;}blockquote cite{font-size:1rem;line-height:1.53rem;color:hsla(204,5.275997423999999%,0%,0.46);font-weight:400;font-style:normal;}div.gatsby-highlight{margin-bottom:20px;}</style><link href="//fonts.googleapis.com/css?family=Merriweather:700|Source+Sans+Pro:400,400i,700" rel="stylesheet" type="text/css"/><style id="gatsby-inlined-css">.editor .wrap-guide{background:hsla(0,0%,100%,.1)}.editor .indent-guide{color:hsla(0,0%,100%,.15)}.editor,.editor .gutter{background-color:#282828;color:#f8f8f2}.editor.is-focused .cursor{border-color:#f8f8f0}.editor.is-focused .line-number.cursor-line-no-selection,.editor.is-focused .selection .region{background-color:#49483e}.editor .invisible-character{color:hsla(0,0%,84%,.15)}.editor .comment{color:#75715e}.editor .string{color:#e6db74}.editor .constant.character,.editor .constant.language,.editor .constant.numeric,.editor .constant.other{color:#ae81ff}.editor .keyword,.editor .storage{color:#f92672}.editor .storage.type{font-style:italic;color:#66d9ef}.editor .entity.name.class,.editor .entity.other.inherited-class{text-decoration:underline;color:#a6e22e}.editor .entity.other.inherited-class{font-style:italic}.editor .entity.name.function{color:#a6e22e}.editor .entity.name.instance{color:#66d9ef}.editor .variable.parameter{font-style:italic;color:#fd971f}.editor .entity.name.tag{color:#f92672}.editor .entity.other.attribute-name{color:#a6e22e}.editor .support.constant,.editor .support.function{color:#66d9ef}.editor .support.class,.editor .support.type{font-style:italic;color:#66d9ef}.editor .invalid{color:#f8f8f0;background-color:#f92672}.editor .invalid.deprecated{color:#f8f8f0;background-color:#ae81ff}.editor .class.jade{color:#ae81ff}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:100;src:local("Montserrat Thin "),local("Montserrat-Thin"),url(/ho_blog/static/montserrat-latin-100.50d27986.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-100.5e334eff.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:100;src:local("Montserrat Thin italic"),local("Montserrat-Thinitalic"),url(/ho_blog/static/montserrat-latin-100italic.8c070533.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-100italic.03e19243.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:200;src:local("Montserrat Extra Light "),local("Montserrat-Extra Light"),url(/ho_blog/static/montserrat-latin-200.4343d3d9.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-200.f2022ecd.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:200;src:local("Montserrat Extra Light italic"),local("Montserrat-Extra Lightitalic"),url(/ho_blog/static/montserrat-latin-200italic.116c4c4b.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-200italic.89614a60.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:300;src:local("Montserrat Light "),local("Montserrat-Light"),url(/ho_blog/static/montserrat-latin-300.d2ad295b.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-300.3a371ee0.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:300;src:local("Montserrat Light italic"),local("Montserrat-Lightitalic"),url(/ho_blog/static/montserrat-latin-300italic.f6b6bf24.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-300italic.16521668.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:400;src:local("Montserrat Regular "),local("Montserrat-Regular"),url(/ho_blog/static/montserrat-latin-400.240a8444.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-400.b20cc131.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:400;src:local("Montserrat Regular italic"),local("Montserrat-Regularitalic"),url(/ho_blog/static/montserrat-latin-400italic.86172bb8.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-400italic.9405e787.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:500;src:local("Montserrat Medium "),local("Montserrat-Medium"),url(/ho_blog/static/montserrat-latin-500.fb8d6b71.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-500.50825d47.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:500;src:local("Montserrat Medium italic"),local("Montserrat-Mediumitalic"),url(/ho_blog/static/montserrat-latin-500italic.c0a555a4.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-500italic.635de59c.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:600;src:local("Montserrat SemiBold "),local("Montserrat-SemiBold"),url(/ho_blog/static/montserrat-latin-600.d5615136.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-600.f300da4f.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:600;src:local("Montserrat SemiBold italic"),local("Montserrat-SemiBolditalic"),url(/ho_blog/static/montserrat-latin-600italic.10f29d13.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-600italic.2bc37d86.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:700;src:local("Montserrat Bold "),local("Montserrat-Bold"),url(/ho_blog/static/montserrat-latin-700.7d77e1f0.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-700.81826529.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:700;src:local("Montserrat Bold italic"),local("Montserrat-Bolditalic"),url(/ho_blog/static/montserrat-latin-700italic.1dd2b53f.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-700italic.c162d257.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:800;src:local("Montserrat ExtraBold "),local("Montserrat-ExtraBold"),url(/ho_blog/static/montserrat-latin-800.d4e7bf86.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-800.895aadbf.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:800;src:local("Montserrat ExtraBold italic"),local("Montserrat-ExtraBolditalic"),url(/ho_blog/static/montserrat-latin-800italic.fc0cbe44.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-800italic.b3362875.woff) format("woff")}@font-face{font-family:Montserrat;font-style:normal;font-display:swap;font-weight:900;src:local("Montserrat Black "),local("Montserrat-Black"),url(/ho_blog/static/montserrat-latin-900.c8bdd772.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-900.1b99ef78.woff) format("woff")}@font-face{font-family:Montserrat;font-style:italic;font-display:swap;font-weight:900;src:local("Montserrat Black italic"),local("Montserrat-Blackitalic"),url(/ho_blog/static/montserrat-latin-900italic.cb72c1f9.woff2) format("woff2"),url(/ho_blog/static/montserrat-latin-900italic.b78bb9f8.woff) format("woff")}@font-face{font-family:Merriweather;font-style:normal;font-display:swap;font-weight:300;src:local("Merriweather Light "),local("Merriweather-Light"),url(/ho_blog/static/merriweather-latin-300.f015f1e9.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-300.92dfe81b.woff) format("woff")}@font-face{font-family:Merriweather;font-style:italic;font-display:swap;font-weight:300;src:local("Merriweather Light italic"),local("Merriweather-Lightitalic"),url(/ho_blog/static/merriweather-latin-300italic.7fd86b32.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-300italic.878b76f5.woff) format("woff")}@font-face{font-family:Merriweather;font-style:normal;font-display:swap;font-weight:400;src:local("Merriweather Regular "),local("Merriweather-Regular"),url(/ho_blog/static/merriweather-latin-400.12dbf4c0.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-400.1fffad22.woff) format("woff")}@font-face{font-family:Merriweather;font-style:italic;font-display:swap;font-weight:400;src:local("Merriweather Regular italic"),local("Merriweather-Regularitalic"),url(/ho_blog/static/merriweather-latin-400italic.1e0d3e81.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-400italic.de18d4c4.woff) format("woff")}@font-face{font-family:Merriweather;font-style:normal;font-display:swap;font-weight:700;src:local("Merriweather Bold "),local("Merriweather-Bold"),url(/ho_blog/static/merriweather-latin-700.dc8fec81.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-700.d7d2ed8e.woff) format("woff")}@font-face{font-family:Merriweather;font-style:italic;font-display:swap;font-weight:700;src:local("Merriweather Bold italic"),local("Merriweather-Bolditalic"),url(/ho_blog/static/merriweather-latin-700italic.b7b7e5da.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-700italic.6210a5fc.woff) format("woff")}@font-face{font-family:Merriweather;font-style:normal;font-display:swap;font-weight:900;src:local("Merriweather Black "),local("Merriweather-Black"),url(/ho_blog/static/merriweather-latin-900.43f870d5.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-900.8f3806df.woff) format("woff")}@font-face{font-family:Merriweather;font-style:italic;font-display:swap;font-weight:900;src:local("Merriweather Black italic"),local("Merriweather-Blackitalic"),url(/ho_blog/static/merriweather-latin-900italic.168c1ab2.woff2) format("woff2"),url(/ho_blog/static/merriweather-latin-900italic.ae7778f0.woff) format("woff")}</style></head><body><div id="___gatsby"><div style="max-width:52.02rem;margin-left:auto;margin-right:auto;padding:2.295rem 1.1475rem;" data-reactroot="" data-reactid="1" data-react-checksum="-28292591"><h3 style="font-family:Montserrat, sans-serif;margin-top:0;" data-reactid="2"><a style="box-shadow:none;text-decoration:none;color:inherit;" href="/ho_blog/" data-reactid="3">Merlin Tec Blog</a></h3><div data-reactid="4"><!-- react-empty: 5 --><h1 data-reactid="6">build-react</h1><p style="font-size:0.87055rem;line-height:1.53rem;display:block;margin-bottom:1.53rem;margin-top:-1.53rem;" data-reactid="7">June 03, 2018</p><div data-reactid="8"><p>이 글은 아래 링크에 있는 글을 참조 했습니다.
<a href="https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5">참조</a></p>
<h2>Rendering DOM element</h2>
<p>우리가 render 할 때 필요한게 뭔지 설명하는 plain JS object 를 하나 만들 것이다.
이것을 우리는 element 라고 부를 것이다. 여기서는 <code>type</code> 과 <code>props</code>라는 2 개의 프로퍼티가 요구된다.
<code>type</code>은 기본 string 또는 function 이 될 수 있고, props 는 비어있을 수 있는 객체가 될것이다. null 은 오지 않는다. 여기서 props 는 children 이라는 프로퍼티도 가질 것이다. children 은 배열로 구성될 것이다.</p>
<p>예를 들면 아래와 같다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;element&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;type:&nbsp;&#39;div&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props:&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;&#39;container&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;[</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;type:&nbsp;&#39;input&#39;,&nbsp;props:&nbsp;{&nbsp;value:&nbsp;&#39;foo&#39;,&nbsp;type:&nbsp;&#39;text&#39;&nbsp;}&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;type:&nbsp;&#39;a&#39;,&nbsp;props:&nbsp;{&nbsp;href:&nbsp;&#39;/bar&#39;&nbsp;}&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;type:&nbsp;&#39;span&#39;,&nbsp;props:&nbsp;{}&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;],</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>위 객체는 아래 dom 을 설명하는 것이 된다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text html basic"><span class="meta tag block any html"><span class="punctuation definition tag begin html"><span>&lt;</span></span><span class="entity name tag block any html"><span>div</span></span><span>&nbsp;</span><span class="meta attribute-with-value id html"><span class="entity other attribute-name id html"><span>id</span></span><span class="punctuation separator key-value html"><span>=</span></span><span class="string quoted double html"><span class="punctuation definition string begin html"><span>&quot;</span></span><span class="meta toc-list id html"><span>container</span></span><span class="punctuation definition string end html"><span>&quot;</span></span></span></span><span class="punctuation definition tag end html"><span>&gt;</span></span></span></span></div><div class="line"><span class="text html basic"><span>&nbsp;&nbsp;</span><span class="meta tag inline any html"><span class="punctuation definition tag begin html"><span>&lt;</span></span><span class="entity name tag inline any html"><span>input</span></span><span>&nbsp;</span><span class="entity other attribute-name html"><span>value</span></span><span>=</span><span class="string quoted double html"><span class="punctuation definition string begin html"><span>&quot;</span></span><span>foo</span><span class="punctuation definition string end html"><span>&quot;</span></span></span><span>&nbsp;</span><span class="entity other attribute-name html"><span>type</span></span><span>=</span><span class="string quoted double html"><span class="punctuation definition string begin html"><span>&quot;</span></span><span>text</span><span class="punctuation definition string end html"><span>&quot;</span></span></span><span class="punctuation definition tag end html"><span>&gt;</span></span></span></span></div><div class="line"><span class="text html basic"><span>&nbsp;&nbsp;</span><span class="meta tag any html"><span class="punctuation definition tag html"><span>&lt;</span></span><span class="entity name tag html"><span>a</span></span><span>&nbsp;</span><span class="entity other attribute-name html"><span>href</span></span><span>=</span><span class="string quoted double html"><span class="punctuation definition string begin html"><span>&quot;</span></span><span>/bar</span><span class="punctuation definition string end html"><span>&quot;</span></span></span><span class="punctuation definition tag html"><span>&gt;</span><span class="meta scope between-tag-pair html"><span>&lt;</span></span><span>/</span></span><span class="entity name tag html"><span>a</span></span><span class="punctuation definition tag html"><span>&gt;</span></span></span></span></div><div class="line"><span class="text html basic"><span>&nbsp;&nbsp;</span><span class="meta tag any html"><span class="punctuation definition tag html"><span>&lt;</span></span><span class="entity name tag html"><span>span</span></span><span class="punctuation definition tag html"><span>&gt;</span><span class="meta scope between-tag-pair html"><span>&lt;</span></span><span>/</span></span><span class="entity name tag html"><span>span</span></span><span class="punctuation definition tag html"><span>&gt;</span></span></span></span></div><div class="line"><span class="text html basic"><span class="meta tag block any html"><span class="punctuation definition tag begin html"><span>&lt;/</span></span><span class="entity name tag block any html"><span>div</span></span><span class="punctuation definition tag end html"><span>&gt;</span></span></span></span></div></pre>
<p>보통 element 를 위 처럼 만들지 않고 <code>createElement</code>를 사용해서 만들기에 우리도 하나 만들어 볼 것이다.
그러기 전에 해당 element 를 받았을때 실제 dom 에 render 하는 함수를 만들어 보자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;render(element,&nbsp;parentDom)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;document.createElement(type)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childElement&nbsp;=&nbsp;props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;childElement.forEach(childElement&nbsp;=&gt;&nbsp;render(childElement,&nbsp;dom))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;parentDom.appendChild(dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>render(element,&nbsp;document.getElementById(&#39;root&#39;))</span></span></div></pre>
<p>위에서 빠뜨린 부분이 있다면 프로퍼티들과 이벤트 리스너이다. 빠뜨린 부분들을 다시 작성해 보자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;render(element,&nbsp;parentDom)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;document.createElement(type)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;start</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isListener&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;name.startWith(&#39;on&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isListener)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;eventType&nbsp;=&nbsp;name.toLowerCase().substring(2)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom.addEventListener(eventType,&nbsp;props[name])</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isAttribute&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;!isListener(name)&nbsp;&amp;&amp;&nbsp;name&nbsp;!=&nbsp;&#39;children&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isAttribute)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom[name]&nbsp;=&nbsp;props[name]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;end</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childElement&nbsp;=&nbsp;props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;childElement.forEach(childElement&nbsp;=&gt;&nbsp;render(childElement,&nbsp;dom))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;parentDom.appendChild(dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>다음은 DOM 의 Text Nodes 를 render 하는 방법이다.
여기서 Text Node 를 표현하는 방법은 children 배열에 element 객체가 아닌 plain text 가 들어간 경우가 되겠다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;reactElement&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;type:&nbsp;&#39;span&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props:&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;[&#39;Foo&#39;],</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>하지만 여기서 children 배열에 type 과 props 가 들어간 객체만 온다는 룰을 가지고 있으면 우린 더 적은 if 문을 만들 수 있을 것이다. 해서 text 타입은 “TEXT ELEMENT” 라고 props 에는 nodeValue 라는 프로퍼티를 갖게 만들자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;textElement&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;type:&nbsp;&#39;span&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props:&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;[</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&#39;TEXT_ELEMENT&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props:&nbsp;{&nbsp;nodeValue:&nbsp;&#39;Foo&#39;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;],</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>여기서 우리가 정의한 text element 대로 render 하는 함수를 다시 수정해보자. 여기서 달라지는 점이 있다면 일반 dom type 일 경우에는 <code>createElement</code> 의 dom api 를 썼을텐데 text 는 <code>createTextNode</code> 라는 dom api 를 사용하자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;render(element,&nbsp;parentDom)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Create&nbsp;DOM&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isTextElement&nbsp;=&nbsp;type&nbsp;===&nbsp;&#39;TEXT&nbsp;ELEMENT&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;isTextElement</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;document.createTextNode(&#39;&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;document.createElement(type)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Add&nbsp;event&nbsp;listeners</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isListener&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;name.startsWith(&#39;on&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isListener)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;eventType&nbsp;=&nbsp;name.toLowerCase().substring(2)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom.addEventListener(eventType,&nbsp;props[name])</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Set&nbsp;properties</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;여기서&nbsp;nodeValue도&nbsp;셋팅한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isAttribute&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;!isListener(name)&nbsp;&amp;&amp;&nbsp;name&nbsp;!==&nbsp;&#39;children&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isAttribute)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom[name]&nbsp;=&nbsp;props[name]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Render&nbsp;children</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childElements&nbsp;=&nbsp;props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;childElements.forEach(childElement&nbsp;=&gt;&nbsp;render(childElement,&nbsp;dom))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Append&nbsp;to&nbsp;parent</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;parentDom.appendChild(dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<h2>Element creation and JSX</h2>
<p>위 Element 를 좀 더 쉽게 만들기 위해 JSX 를 사용하면 쉽게 읽히면서도 쉽게 표현이 된다. 여기서 JSX 는 우리가 DOM 에 무엇을 표현하고 싶은지를 설명해주는 한 방법이다.</p>
<p>바벨을 사용한다면 JSX 표현은 다음과 같이 변경된다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;element&nbsp;=&nbsp;(</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&lt;div&nbsp;id=&quot;container&quot;&gt;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;value=&quot;foo&quot;&nbsp;type=&quot;text&quot;&nbsp;/&gt;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href=&quot;/bar&quot;&gt;bar&lt;/a&gt;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&nbsp;onClick={e&nbsp;=&gt;&nbsp;alert(&#39;Hi&#39;)}&gt;click&nbsp;me&lt;/span&gt;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&lt;/div&gt;</span></span></div><div class="line"><span class="text plain null-grammar"><span>)</span></span></div></pre>
<p><a href="https://babeljs.io/repl/#?babili=false&#x26;evaluate=true&#x26;lineWrap=false&#x26;presets=react&#x26;targets=&#x26;browsers=&#x26;builtIns=false&#x26;debug=false&#x26;code=%2F**%20%40jsx%20createElement%20*%2F%0A%0Aconst%20element%20%3D%20%28%0A%20%20%3Cdiv%20id%3D%22container%22%3E%0A%20%20%20%20%3Cinput%20value%3D%22foo%22%20type%3D%22text%22%20%2F%3E%0A%20%20%20%20%3Ca%20href%3D%22%2Fbar%22%3Ebar%3C%2Fa%3E%0A%20%20%20%20%3Cspan%20onClick%3D%7Be%20%3D%3E%20alert%28%22Hi%22%29%7D%3Eclick%20me%3C%2Fspan%3E%0A%20%20%3C%2Fdiv%3E%0A%29%3B">try it on babel REPL</a></p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;element&nbsp;=&nbsp;createElement(</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&#39;div&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;{&nbsp;id:&nbsp;&#39;container&#39;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;createElement(&#39;input&#39;,&nbsp;{&nbsp;value:&nbsp;&#39;foo&#39;,&nbsp;type:&nbsp;&#39;text&#39;&nbsp;}),</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;createElement(&#39;a&#39;,&nbsp;{&nbsp;href:&nbsp;&#39;/bar&#39;&nbsp;},&nbsp;&#39;bar&#39;),</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;createElement(&#39;span&#39;,&nbsp;{&nbsp;onClick:&nbsp;e&nbsp;=&gt;&nbsp;alert(&#39;Hi&#39;)&nbsp;},&nbsp;&#39;click&nbsp;me&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>)</span></span></div></pre>
<p>그래서 우린 createElement 함수를 만들어 줄 것이다. 첫번째 인자는 type 인자이고 두번째 인자는 props 이다. 그리고 나머지 인자들은 children 이다.
createElement 함수는 props 객체를 만들어주고 두번째 인자의 값들을 전부 할당해 주어야 한다. 또, children 프로퍼티는 두번째 이후로 오는 인자들을 배열로 만들어서 props 의 children 에 셋팅해준다. 그리고 type 과 props 를 반환하면 된다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;createElement(type,&nbsp;props,&nbsp;...args)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;Object.assign({},&nbsp;config)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;hasChildren&nbsp;=&nbsp;args.length&nbsp;&gt;&nbsp;0</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props.children&nbsp;=&nbsp;hasChildren&nbsp;?&nbsp;[].concat(...args)&nbsp;:&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;{&nbsp;type,&nbsp;props&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>위 createElement 함수에서 text node 에 해당하는게 하나 빠져있다. 위 함수대로 작동을 한다면 아래 span 의 text node 의 경우에 그냥 string 값이 들어갈 것이다.</p>
<p>아까 우린 위에서 text node 도 <code>{ type: TEXT_ELEMENT, props: {nodeValue: 'test'}}</code> 로 만들어 주기로 했었다. 해서 createElement 를 수정해야 한다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;spanElement&nbsp;=&nbsp;createElement(</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&#39;span&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;{&nbsp;onClick:&nbsp;e&nbsp;=&gt;&nbsp;alert(&#39;Hi&#39;)&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&#39;click&nbsp;me&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>spanElement&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;type:&nbsp;&#39;span&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props:&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;onClick:&nbsp;e&nbsp;=&gt;&nbsp;alert(&#39;Hi&#39;),</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;[&#39;click&nbsp;me&#39;],&nbsp;//&nbsp;[{type:&nbsp;TEXT_ELEMTN,&nbsp;props:&nbsp;{nodeValue:&nbsp;&#39;click&nbsp;me&#39;}}]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>수정해 보자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;TEXT_ELEMENT&nbsp;=&nbsp;&#39;TEXT&nbsp;ELEMENT&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;createElement(type,&nbsp;config,&nbsp;...args)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;props&nbsp;=&nbsp;Object.assign({},&nbsp;config)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;hasChildren&nbsp;=&nbsp;args.length&nbsp;&gt;&nbsp;0</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;rawChildren&nbsp;=&nbsp;hasChildren&nbsp;?&nbsp;[].concat(...args)&nbsp;:&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;children&nbsp;배열을&nbsp;돌면서&nbsp;textElement는&nbsp;TEXT&nbsp;ELEMENT&nbsp;타입으로&nbsp;변환해서&nbsp;넣어준다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props.children&nbsp;=&nbsp;rawChildren</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(c&nbsp;=&gt;&nbsp;c&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;c&nbsp;!==&nbsp;false)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.map(c&nbsp;=&gt;&nbsp;(c&nbsp;instanceof&nbsp;Object&nbsp;?&nbsp;c&nbsp;:&nbsp;createTextElement(c)))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;{&nbsp;type,&nbsp;props&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;createTextElement(value)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;createElement(TEXT_ELEMENT,&nbsp;{&nbsp;nodeValue:&nbsp;value&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<h2>Instances, reconciliation and virtual DOM</h2>
<p>이번에는 DOM 을 어떻게 업데이트 시키는지에 대해서 포커스를 두자.
우선 setState 를 설명하기 전까지 dom update 를 할수 있는 방법은 달라진 element 를 가지고 render 함수를 반복해서 시키는 방법이다.</p>
<p>기존 render 는 실제 DOM 을 만들어서 appendChild 를 하는 방식이라서 update 에 적합하지가 않다.
그래서 처음으로 바꿔야 할 부분은 dom 을 replace 하는 작업이고, render 함수 마지막 부분에 parent dom 이 child dom 을 가지고 있는지 확인한다. 만약 그렇다면 새로운 element 로 만든 dom 을 replace 해준다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;render(element,&nbsp;parentDom)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;...</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Create&nbsp;dom&nbsp;from&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;...</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Append&nbsp;or&nbsp;replace&nbsp;dom</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(!parentDom.lastChild)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.appendChild(dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.replaceChild(dom,&nbsp;parentDom.lastChild)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>하지만 좀 더 복잡한 케이스에서는 모든 child node 들을 재 생성 하는 퍼포먼스 비용이 만족스럽지 않는다.
그래서 우린 현재 새로 생성한 elements tree 와 이전 render 를 호출했을 때 사용되었던 element tree 를 비교해서 달라진 곳만 update 시켜야 한다.</p>
<h3>Virtual DOM and Reconciliation</h3>
<p>React 에서는 위에서 말한 달라진 곳을 비교하는것 이 “diffing” 프로세싱을 <strong>reconciliation</strong> 이라 부릅니다. 우리도 이와같이 하기 위해서 이전 render 에 사용 되었던 element tree 구조를 보관할 필요가 있고 이것을 새로운 element tree 구조와 비교할 것입니다. 다른말로 하면 우리의 virtual DOM 버젼을 계속 유지해 나갈 것이다.</p>
<p>virtual DOM 안에 있는 노드들은 무엇을 해야 할까요? 이미 그것은 element 로 사용을 하고 있고 element 들은 <code>props.children</code> 프로퍼티를 이미 가지고 있다. 이 프로퍼티는 tree 구조 처럼 element 들 탐색을 가능하게 한다. 하지만 여기서 2 가지 문제점이 있는데, 하나는 reconciliation 을 좀 더 쉽게 진행하기 위해서 각 노드의 virtual DOM 에 실제 DOM reference 를 가지고 있어야 한다는 점이고, element 들을 immutable 하게 유지해야 한다. 두번째 문제는 우리는 나중에 본인만의 state 를 갖고 있는 Components 를 지원해야하고 element 들이 그것을 다루지 못하게 해야한다.</p>
<h3>Instances</h3>
<p>그래서 우리는 새로운 용어인 Instances 를 소개하겠다. instance 는 DOM 에 렌더링 된 element 를 나타냅니다. 또한 element, dom, 그리고 childInstances 를 지닌 plain 객체 입니다. childInstances 는 element children 의 instancese 들을 지닌 배열입니다.</p>
<p>각 DOM 노드는 매칭된 instance 를 가지고 있을 것입니다. reconciliation 알고리즘의 한가지 목표는 가능한한 많이 instance 를 creating 또는 removing 을 피하는 것입니다.
여기서 instance 를 creating 그리고 removing 한다는 것은 DOM tree 를 수정해야 한다는 의미 일 것입니다.
instance 를 재사용할수록 DOM 트리를 수정하는 횟수가 줄어 듭니다.</p>
<h3>Refactoring</h3>
<p>여기서 우리 render 함수를 reconciliation 알고리즘을 적용해보고, element 를 주어지면 instance 를 생성하는 instantiate 함수를 추가해보자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>let&nbsp;rootInstance&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;render(element,&nbsp;container)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;prevInstance&nbsp;=&nbsp;rootInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;nextInstance&nbsp;=&nbsp;reconcile(container,&nbsp;prevInstance,&nbsp;element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;rootInstance&nbsp;=&nbsp;nextInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcile(parentDom,&nbsp;instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;부모&nbsp;real&nbsp;DOM,&nbsp;이전&nbsp;instance&nbsp;,&nbsp;새로운&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;초기&nbsp;render&nbsp;시</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.appendChild(newInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;update&nbsp;render&nbsp;시</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.replaceChild(newInstance.dom,&nbsp;instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;instantiate(element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Create&nbsp;DOM&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isTextElement&nbsp;=&nbsp;type&nbsp;===&nbsp;&#39;TEXT&nbsp;ELEMENT&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;isTextElement</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;document.createTextNode(&#39;&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;document.createElement(type)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Add&nbsp;event&nbsp;listeners</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isListener&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;name.startsWith(&#39;on&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isListener)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;eventType&nbsp;=&nbsp;name.toLowerCase().substring(2)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom.addEventListener(eventType,&nbsp;props[name])</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Set&nbsp;properties</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isAttribute&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;!isListener(name)&nbsp;&amp;&amp;&nbsp;name&nbsp;!=&nbsp;&#39;children&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isAttribute)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom[name]&nbsp;=&nbsp;props[name]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Instantiate&nbsp;and&nbsp;append&nbsp;children</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childElements&nbsp;=&nbsp;props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childInstances&nbsp;=&nbsp;childElements.map(instantiate)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childDoms&nbsp;=&nbsp;childInstances.map(childInstance&nbsp;=&gt;&nbsp;childInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;childDoms.forEach(childDom&nbsp;=&gt;&nbsp;dom.appendChild(childDom))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;instance&nbsp;=&nbsp;{&nbsp;dom,&nbsp;element,&nbsp;childInstances&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>이전과 코드는 같지만, 여기서 다른점은 마지막으로 호출한 render 에서 나온 instance 를 저장하고 있다는점이다.
dom nodes 를 재사용하기 위해서는, dom 프로퍼티들을 update 할 방법이 필요하다. ( className, style, onCLick, etc…) 그래서 dom 프로퍼티를 update 하는 함수를 작성해보자.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;instantiate(element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Create&nbsp;DOM&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isTextElement&nbsp;=&nbsp;type&nbsp;===&nbsp;&#39;TEXT&nbsp;ELEMENT&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;isTextElement</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;document.createTextNode(&#39;&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;document.createElement(type)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;updateDomProperties(dom,&nbsp;[],&nbsp;props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Instantiate&nbsp;and&nbsp;append&nbsp;children</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childElements&nbsp;=&nbsp;props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childInstances&nbsp;=&nbsp;childElements.map(instantiate)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childDoms&nbsp;=&nbsp;childInstances.map(childInstance&nbsp;=&gt;&nbsp;childInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;childDoms.forEach(childDom&nbsp;=&gt;&nbsp;dom.appendChild(childDom))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;instance&nbsp;=&nbsp;{&nbsp;dom,&nbsp;element,&nbsp;childInstances&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;updateDomProperties(dom,&nbsp;prevProps,&nbsp;nextProps)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isEvent&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;name.startsWith(&#39;on&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isAttribute&nbsp;=&nbsp;name&nbsp;=&gt;&nbsp;!isEvent(name)&nbsp;&amp;&amp;&nbsp;name&nbsp;!=&nbsp;&#39;children&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Remove&nbsp;event&nbsp;listeners</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(prevProps)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isEvent)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;eventType&nbsp;=&nbsp;name.toLowerCase().substring(2)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom.removeEventListener(eventType,&nbsp;prevProps[name])</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Remove&nbsp;attributes</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(prevProps)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isAttribute)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom[name]&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Set&nbsp;attributes</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(nextProps)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isAttribute)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom[name]&nbsp;=&nbsp;nextProps[name]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Add&nbsp;event&nbsp;listeners</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Object.keys(nextProps)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.filter(isEvent)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(name&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;eventType&nbsp;=&nbsp;name.toLowerCase().substring(2)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom.addEventListener(eventType,&nbsp;nextProps[name])</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>updateDomProperties</code> 함수는 이전 프로퍼티들을 모두 제거하고 새로운 것들을 추가한다. 만약 프로퍼티가 바뀌지 않았다면 바꾸지 않는다. 그래서 많은 불필요한 업데이트를 할 것입니다. 그러나 간단하게하기 위해 지금은 그대로 두겠습니다.</p>
<h3>Reusing DOM nodes</h3>
<p>reconciliation 알고리즘은 DOM nodes 를 가능하면 재 사용하는 것이라고 말했다. 그래서 type 이 같다면 해당 DOM node 를 재사용할 것이다. ( 프로퍼티만 update 할것이다. )</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcile(parentDom,&nbsp;instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.appendChild(newInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(instance.element.type&nbsp;===&nbsp;element.type)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Update&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;여기서&nbsp;instance&nbsp;dom은&nbsp;기존에&nbsp;render&nbsp;되었던&nbsp;Real&nbsp;dom&nbsp;이다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;instance에&nbsp;Real&nbsp;dom을&nbsp;재사용해서&nbsp;프로퍼티들만&nbsp;update&nbsp;시켜준다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateDomProperties(instance.dom,&nbsp;instance.element.props,&nbsp;element.props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.element&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.replaceChild(newInstance.dom,&nbsp;instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<h3>Children Reconciliation</h3>
<p>reconcile 함수에서 가장 중요한 작업을 놓쳤습니다. children 을 실행시키지 않았다는 점이다.
Children reconciliation 은 주요 기술중 하나이다. 여기서는 이전과 현재 tree 구조에서 children 을 매칭 하기 위해 key 라는 추가 프로퍼티가 요구됩니다.
여기서는 오직 같은 children 배열에서 같은 위치의 children 끼리만 비교하겠습니다. 이것이 의미하는 바는 children 순서가 달라지면 DOM nodes 를 재사용하지 못한다는 비용이 든다는 점입니다.</p>
<p>Children reconciliation 을 실행하기 위해선 이전 child instances 인 <code>instance.childInstances</code> 와 새로운 element 의 children <code>element.props.children</code>을 매칭시킬 것입니다. 그리곤 재귀적으로 reconcil 함수를 호출할 것입니다. 또한 reconcile 에서 리턴된 모든 instances 들을 유지해서 childInstances 를 업데이트 할 수 있습니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcile(parentDom,&nbsp;instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.appendChild(newInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(instance.element.type&nbsp;===&nbsp;element.type)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Update&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;타입이&nbsp;같을때&nbsp;dom을&nbsp;재사용한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateDomProperties(instance.dom,&nbsp;instance.element.props,&nbsp;element.props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;그리곤&nbsp;children에&nbsp;대해서&nbsp;reconcile을&nbsp;적용한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;children&nbsp;은&nbsp;배열이기&nbsp;때문에&nbsp;배열&nbsp;처리를&nbsp;위한&nbsp;reconcileChildren&nbsp;함수를&nbsp;활용한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.childInstances&nbsp;=&nbsp;reconcileChildren(instance,&nbsp;element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.element&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;부모가&nbsp;기존&nbsp;인스턴스에서&nbsp;새로운&nbsp;인스턴스로&nbsp;replace&nbsp;한다면&nbsp;그&nbsp;부모&nbsp;children&nbsp;들도&nbsp;새로&nbsp;instance를&nbsp;생성한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.replaceChild(newInstance.dom,&nbsp;instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcileChildren(instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;instance.dom</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childInstances&nbsp;=&nbsp;instance.childInstances</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;nextChildElements&nbsp;=&nbsp;element.props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;newChildInstances&nbsp;=&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;count&nbsp;=&nbsp;Math.max(childInstances.length,&nbsp;nextChildElements.length)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;count;&nbsp;i++)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childInstance&nbsp;=&nbsp;childInstances[i]&nbsp;//&nbsp;이미&nbsp;그려져&nbsp;있는&nbsp;children&nbsp;instance들.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childElement&nbsp;=&nbsp;nextChildElements[i]&nbsp;//&nbsp;새로&nbsp;그려야&nbsp;할&nbsp;children&nbsp;element들</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newChildInstance&nbsp;=&nbsp;reconcile(dom,&nbsp;childInstance,&nbsp;childElement)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;newChildInstances.push(newChildInstance)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;newChildInstances</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>위 코드에서 reconcile 함수 안에서 instance 를 새로 생성하는 경우 ( 맨 처음 render 가 된다거나 type 이 바뀌는 replace 의 경우) 해당 부모의 자식(children) 들도 새로이 instance 를 생성한다. 즉, 부모가 instance 가 만들어지면 그 자식들도 새롭게 instance 를 만든다. 자식이 type 이 같더라도 부모가 바뀌었기 때문에 재 사용하지 못한다. <br/></p>
<p>대신에 부모 element 의 type 이 같아서 dom 을 재사용 할때는 자식들을 하나하나 reconcile 처리 해준다. 이때, 자식도 type 이 같다면 재사용 가능.</p>
<h3>Removing DOM nodes</h3>
<p>만약에 <code>nextChildElements</code>가 <code>childInstances</code> 보다 length 가 더 길다면 reconcileChildren 함수는 reconcile 함수를 호출할 때 instance 를 <code>undifined</code>로 해서 호출할 것이다. 그러면 <code>if(instance == null)</code> 에 걸려서 새로운 instance 를 생성할 것이다. 반면에 반대가 된다면 어떨까?</p>
<p><code>childInstances</code>가 <code>nextChildElements</code> 보다 length 가 더 길다면 reconcile 함수에서 childElement 인자를 <code>undefined</code>를 보낼 것이다. 이때 reconcile 함수에서는 <code>element.type</code> 체크시 에러가 발생하게 된다.</p>
<p>dom 이 제거되는걸 고려하지 않았기 때문이다. 그래서 두가지를 체크 할 것이다. 하나는 reconcile 함수에서 element 가 null 인 경우와 reconcileChildren 함수에서 newChildInstance 가 null 인 경우를 필터해줄 것이다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcile(parentDom,&nbsp;instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.appendChild(newInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(element&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Remove&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;element가&nbsp;null&nbsp;이라는건&nbsp;새로운&nbsp;수정사항이&nbsp;dom을&nbsp;삭제했다는&nbsp;것이다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;그래서&nbsp;그에&nbsp;매칭&nbsp;되는&nbsp;instance.dom&nbsp;을&nbsp;제거해주자.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.removeChild(instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;여기서&nbsp;null&nbsp;을&nbsp;리턴해주기&nbsp;때문에&nbsp;reconcileChildren&nbsp;함수에서&nbsp;null을&nbsp;filter&nbsp;처리&nbsp;한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(instance.element.type&nbsp;===&nbsp;element.type)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Update&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateDomProperties(instance.dom,&nbsp;instance.element.props,&nbsp;element.props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.childInstances&nbsp;=&nbsp;reconcileChildren(instance,&nbsp;element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.element&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.replaceChild(newInstance.dom,&nbsp;instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;인스턴스의&nbsp;childInstance가&nbsp;배열이기&nbsp;때문에&nbsp;이&nbsp;배열을&nbsp;돌면서&nbsp;reconcile&nbsp;처리.</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcileChildren(instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;instance.dom</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;childInstances&nbsp;=&nbsp;instance.childInstances</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;nextChildElements&nbsp;=&nbsp;element.props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;newChildInstances&nbsp;=&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;count&nbsp;=&nbsp;Math.max(childInstances.length,&nbsp;nextChildElements.length)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;count;&nbsp;i++)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childInstance&nbsp;=&nbsp;childInstances[i]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childElement&nbsp;=&nbsp;nextChildElements[i]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newChildInstance&nbsp;=&nbsp;reconcile(dom,&nbsp;childInstance,&nbsp;childElement)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;newChildInstances.push(newChildInstance)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;reconcile&nbsp;함수에서&nbsp;childElement가&nbsp;null인&nbsp;경우에&nbsp;dom이&nbsp;제거됬다고&nbsp;간주하고&nbsp;null&nbsp;을&nbsp;반환할&nbsp;것이다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;newChildInstances.filter(instance&nbsp;=&gt;&nbsp;instance&nbsp;!=&nbsp;null)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<h2>Components and State</h2>
<p>위 코드에서는 몇몇 가지 문제사항이 있었다.</p>
<ul>
<li>모든 변화에 전체 virtual DOM tree 를 reconciliation 을 진행합니다.</li>
<li>State 가 글로벌하게 존재합니다.</li>
<li>state 가 변화 된 후 render 함수를 좀 더 명시적으로 호출해야 합니다.</li>
</ul>
<p>Components 는 이러한 이슈를 해결하는데 도움을 줄수 있습니다.</p>
<ul>
<li>JSX 를 이용해 Custom tag 를 정의 할 수 있습니다.</li>
<li>lifecycle 이벤트에 Hook 을 걸수 있습니다.</li>
</ul>
<p>먼저해야 할 일은 컴포넌트가 확장 될 Component 기본 클래스를 제공하는 것입니다. 우리는 구성 요소 상태를 업데이트하는 데 사용할 <code>partialState</code>를 받는 <code>setState</code> 메서드와 props 매개 변수가있는 생성자가 필요합니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>class&nbsp;Component&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;constructor(props)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.props&nbsp;=&nbsp;props</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;this.state&nbsp;||&nbsp;{}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;setState(partialState)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;Object.assign({},&nbsp;this.state,&nbsp;partialState)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>어플리케이션 코드에서는 이 클래스를 상속받을 것입니다. 그 후에 div 와 span 같이 <code>&#x3C;MyComponent></code> 처럼 사용할 것입니다.
여기서 중요한건 우리가 만들었던 <code>createElement</code> 수정이 필요 없습니다. element <code>type</code>으로 class 컴포넌트를 받고 <code>props</code>를 다룰것입니다.
그래서 여기선 이 element 를 받았을때 component instance( public instances 라고 부릅니다.)를 생성해주는 함수를 만들 필요가 있습니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;createPublicInstance(element,&nbsp;internalInstance)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;publicInstance&nbsp;=&nbsp;new&nbsp;type(props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;publicInstance.__internalInstance&nbsp;=&nbsp;internalInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;publicInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>public instance 생성을 하면서 internal instance(virtual DOM) 의 레퍼런스를 추가적으로 가지고 있을것입니다. 이것은 오직 public instance state 가 변경 되었을때 해당 instance sub-tree 업데이트 하는데 필요합니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>class&nbsp;Component&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;constructor(props)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.props&nbsp;=&nbsp;props</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;this.state&nbsp;||&nbsp;{}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;setState(partialState)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;Object.assign({},&nbsp;this.state,&nbsp;partialState)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateInstance(this.__internalInstance)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;updateInstance(internalInstance)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;parentDom&nbsp;=&nbsp;internalInstance.dom.parentNode</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;element&nbsp;=&nbsp;internalInstance.element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;reconcile(parentDom,&nbsp;internalInstance,&nbsp;element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>instantiate</code> 함수도 update 가 필요합니다. components 들은 public instace 로 생성하고 component 의 <code>render</code> 함수를 child element 를 얻기 위해 호출해준다. 그리곤 해당 element 를 다시 <code>instantiate</code> 함수로 호출해준다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;instantiate(element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;{&nbsp;type,&nbsp;props&nbsp;}&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;isDomElement&nbsp;=&nbsp;typeof&nbsp;type&nbsp;===&nbsp;&#39;string&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(isDomElement)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Instantiate&nbsp;DOM&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;isTextElement&nbsp;=&nbsp;type&nbsp;===&nbsp;TEXT_ELEMENT</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;isTextElement</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;document.createTextNode(&#39;&#39;)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;document.createElement(type)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateDomProperties(dom,&nbsp;[],&nbsp;props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childElements&nbsp;=&nbsp;props.children&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;childElements&nbsp;는&nbsp;배열로&nbsp;들어오기&nbsp;때문에&nbsp;map&nbsp;돌리면서&nbsp;instantiate&nbsp;함수&nbsp;호출해줌.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childInstances&nbsp;=&nbsp;childElements.map(instantiate)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childDoms&nbsp;=&nbsp;childInstances.map(childInstance&nbsp;=&gt;&nbsp;childInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;childDoms.forEach(childDom&nbsp;=&gt;&nbsp;dom.appendChild(childDom))</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;instance&nbsp;=&nbsp;{&nbsp;dom,&nbsp;element,&nbsp;childInstances&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;element.type이&nbsp;class&nbsp;일&nbsp;경우.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Instantiate&nbsp;component&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;instance&nbsp;=&nbsp;{}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;publicInstance&nbsp;=&nbsp;createPublicInstance(element,&nbsp;instance)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childElement&nbsp;=&nbsp;publicInstance.render()</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;child&nbsp;인스턴스가&nbsp;하나임.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childInstance&nbsp;=&nbsp;instantiate(childElement)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;dom&nbsp;=&nbsp;childInstance.dom</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;Object.assign(instance,&nbsp;{&nbsp;dom,&nbsp;element,&nbsp;childInstance,&nbsp;publicInstance&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>component elements 에 해당하는 internal instance 과 dom element 들은 다르다. Component internal instance 들은 오직 하나의 child(render 함수에서 리턴되는) 만 가지고 있다. 그래서 internal instance 들은 dom instances 들이 가지고 있는 배열인 <code>childInstances</code> 대신에 childInstance 프로퍼티 하나를 가지고 있다. 또한, component internal instance 들은 public instance 를 가지고 있을 필요가 있다. 그래야 render 함수가 reconciliation 하는 동안 불려질수 있기 때문이다.</p>
<p>한가지 놓친것이 있다면 component instance 의 reconciliation 를 다루는 것이다. 그래서 우린 reconciliation algorithm 에 한가지 케이스를 더 추가할 것이다. children reconciliation 을 다루지 않아도 되는 한가지 child 만 가지고 있는 component instance 가 주어졌을때, 우린 public instance 의 props 를 update 시키고 child 를 re-render 시켜주면 된다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcile(parentDom,&nbsp;instance,&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.appendChild(newInstance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(element&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Remove&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.removeChild(instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(instance.element.type&nbsp;!==&nbsp;element.type)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newInstance&nbsp;=&nbsp;instantiate(element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;parentDom.replaceChild(newInstance.dom,&nbsp;instance.dom)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(typeof&nbsp;element.type&nbsp;===&nbsp;&#39;string&#39;)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Update&nbsp;dom&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateDomProperties(instance.dom,&nbsp;instance.element.props,&nbsp;element.props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.childInstances&nbsp;=&nbsp;reconcileChildren(instance,&nbsp;element)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.element&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//Update&nbsp;composite&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.publicInstance.props&nbsp;=&nbsp;element.props</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childElement&nbsp;=&nbsp;instance.publicInstance.render()</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;oldChildInstance&nbsp;=&nbsp;instance.childInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childInstance&nbsp;=&nbsp;reconcile(parentDom,&nbsp;oldChildInstance,&nbsp;childElement)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.dom&nbsp;=&nbsp;childInstance.dom</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.childInstance&nbsp;=&nbsp;childInstance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance.element&nbsp;=&nbsp;element</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>이게 전부이다. 이 코드를 사용해서 활용한 예제이다. : <a href="https://codepen.io/pomber/pen/RVqBrx">codepen</a></p>
<h2>Fiber: Incremental reconciliation</h2>
<p>리액트 16 버젼이 출시 되었다. 그것은 리액트의 코드 대부분을 재 작성해야 할 필요가 생긴 새로운 내부적인 아키텍쳐를 가지고 있다.
이것은 예전 아키텍처로는 개발하기 힘든 일부 기능이 선적되었음을 의미합니다. 또한 이 시리즈에서 작성한 대부분의 코드는 현재 가치가 없다는 것을 의미합니다.</p>
<p>이제는 16 에서 사용하는 새로운 아키텍쳐를 사용해서 다시 코드를 작성해볼 예정이다. 특히, 구조, 변수들, 함수이름들을 리액트 코드베이스로 부터 가져와서 작성할 것입니다.
여기서 우리가 건들지 않아도 되는 API 는 다음과 같습니다.</p>
<ul>
<li>createElemetn()</li>
<li>render() (오직 DOM 을 rendering 하는 함수)</li>
<li>Component ( setState() 메서드를 포함한. context 나 life cycle 은 미포함)</li>
</ul>
<p>이제 왜 우리가 예전 코드를 다시 작성해야 하는지를 설명하겠다.</p>
<h3>Why Fiber</h3>
<p>브라우저의 메인 쓰레드는 시간을 많이 쓰는 무엇인가로 인해 매우 바쁘게 움직있다고 할때, 매우 중요한 task 들은 끝날때 까지 기다려야 한다.</p>
<p>이런 문제를 위해서 몇가지 데모를 준비했다. <a href="https://pomber.github.io/incremental-rendering-demo/react-sync.html">데모</a>에서 행서들이 도는걸 유지하기 위해서 메인 쓰레드는 매 16ms 마다 사용가능 하도록 유지 시켜주어야 한다. 만약 이 메인쓰레드가 다른 무엇인가로 blocked 당했다고 한다면 여기서 매 200ms 라고 하자. 메인 쓰레드가 다시 자유로워 질때 까지 행성들이 멈춰있고 해당 프레임이 사라지는걸 확인 할 수 있을 것이다.</p>
<p>무엇이 메인 쓰레드 즉, 몇 에니메이션을 부드럽고 UI 응답을 유지하기 위해 예비의 마이크로 초도 둘수없게 바쁘게 하는가?</p>
<p>reconciliation 코드를 기억하는가? 한번 reconciliation 코드를 실행하면 멈추지 않는다. 메인 스레드가 다른 작업을 수행해야하는 경우 reconciliation 코드는 대기해야합니다. 그리고 이 reconciliation 코드는 많은 재귀 호출로 인해서 지연될 수 있는 코드다. 이런이유로 우리는 해당 코드를 재귀 호출을 루프로 교체가능한 새로운 데이터 구조를 사용하는 reconciliation 코드를 재 작성해야 합니다.</p>
<h3>Scheduling micro-tasks</h3>
<p>우린 이제 작업을 작은 단위로 나눌 필요가 있습니다. 짧은 시간동안 동작하기 위해서 짧은 단위로 나눈다. 메인 스레드가 더 우선 순위가 높은 작업을 수행하게하고 보류중인 작업이 있으면 작업을 끝내기 위해 다시 돌아옵니다.
이 작업을 돕기 위해서 <code>requestIdelCallback()</code> 함수를 이용 할 것입니다. 이것은 callback 함수를 큐에 넣어 두는데 이것은 브라우저가 idle 타임에 호출이 되고, 얼만큼 이용가능한 시간인지 설명해주는 <code>deadline</code> 파라미터를 포함하고 있다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;ENOUGH_TIME&nbsp;=&nbsp;1&nbsp;//&nbsp;milliseconds</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>let&nbsp;workQueue&nbsp;=&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>let&nbsp;nextUnitOfWork&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;schedule(task)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;workQueue.push(task)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;requestIdleCallback(performWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;requestIdleCallback&nbsp;인자로&nbsp;들어갈&nbsp;함수</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;이&nbsp;함수는&nbsp;브라우저가&nbsp;idle&nbsp;시점에&nbsp;호출되고</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;deadline&nbsp;파라미터로&nbsp;적절한&nbsp;시간이&nbsp;남았는지를&nbsp;확인해서&nbsp;해당&nbsp;로직을&nbsp;수행한다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;performWork(deadline)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(!nextUnitOfWork)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;nextUnitOfWork&nbsp;=&nbsp;workQueue.shift()</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(nextUnitOfWork&nbsp;&amp;&amp;&nbsp;deadline.timeRemaining()&nbsp;&gt;&nbsp;ENOUGH_TIME)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;nextUnitOfWork&nbsp;=&nbsp;performUnitOfWork(nextUnitOfWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(nextUnitOfWork&nbsp;||&nbsp;workQueue.length&nbsp;&gt;&nbsp;0)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;requestIdleCallback(performWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>실제 작업은 <code>performUnitOfWork</code> 함수에서 일어납니다. <code>performUnitOfWork</code> 안에 우리의 reconciliation code 를 작성할 필요가 있습니다. <code>performUnitOfWork</code> 함수는 작업 조각을 동작시켜야 합니다. 그리곤 다음에 작업을 다시 시작하는 데 필요한 모든 정보를 반환해야 햡니다.
<br />
이런 작업의 조각들을 추적하기위해 fiber 들을 사용할 것입니다. 즉, fiber 는 일련의 작업을 다시 시작하기 위해 만들어졌고 이것을 작업 정보 명세서라고 생각하면 될거 같다.</p>
<h3>The fiber data structure</h3>
<p>우리는 render 를 원하는 각 컴포넌트에 대해 fiber 를 생성할 것입니다. <code>nextUnitOfWork</code> 는 우리가 원하는 다음 작업인 next fiber 를 위한 참조 값입니다. <code>performUnitOfWork</code> 는 fiber 대한 작업을하고 완료가 되면 새로운 fiber 를 리턴합니다.
<br />
fiber 는 어떻게 생겼는가?</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>let&nbsp;fiber&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;tag:&nbsp;HOST_COMPONENT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;type:&nbsp;&#39;div&#39;,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;parent:&nbsp;parentFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;child:&nbsp;childFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;sibling:&nbsp;null,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;alternate:&nbsp;currentFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;stateNode:&nbsp;document.createElement(&#39;div&#39;),</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;props:&nbsp;{&nbsp;children:&nbsp;[],&nbsp;className:&nbsp;&#39;foo&#39;&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;partialState:&nbsp;null,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;effectTag:&nbsp;PLACEMENT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;effects:&nbsp;[],</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>이것은 보통의 자바스크립트 객체입니다.
<br />
우리는 <code>parents</code>, <code>child</code> 그리고 <code>sibling</code> 프로퍼티를 사용하여 component 의 tree 를 설명 하는 fiber 들의 tree 를 구축합니다.
<br />
<code>stateNode</code>는 component instance 에 대한 참조 값이다. 이 값으론 DOM element 또는 유저가 정의한 class component 의 instance 를 가질 수 있습니다.
<br />
예를 들면,</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber01-8a3af4245f4db32744bd10e2fe3f154c-d9514.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABB0lEQVQoz3WRy07EMAxF+//fhliwgwWPSqBOO43r2s7DSVrcMiCGoZalKLJvfK7TeBJyMqGK84QEADihcy6mtK7rO+j9K60H0cQYEfD00avqn1rS0kPoINS61rr8Iw4hLHVhmUstvwtfveOc2sGjJB+y6S0trsR2SORc8pV473kb5O4ZglYtNWqxZLt86zdxyUWCFIO7wQaK5LPmWsqlmnL1McsO0njv643sB7vD/NAycJoohrRNfupi6/K64S/N0PcTABGxyO0TosuZbVRhr/tAbYdwQt19LQ0zjXAeYRQRozAXGqNRHrEA6RmjOTcvDSIKC7N48fM8G4JuW8hHf/vY5xd3WdgnVxgOSWCdrrMAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber01.png"
        title=""
        src="/ho_blog/static/fiber01-8a3af4245f4db32744bd10e2fe3f154c-fb8a0.png"
        srcset="/ho_blog/static/fiber01-8a3af4245f4db32744bd10e2fe3f154c-1a291.png 148w,
/ho_blog/static/fiber01-8a3af4245f4db32744bd10e2fe3f154c-2bc4a.png 295w,
/ho_blog/static/fiber01-8a3af4245f4db32744bd10e2fe3f154c-fb8a0.png 590w,
/ho_blog/static/fiber01-8a3af4245f4db32744bd10e2fe3f154c-d9514.png 600w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>위 예제에서 우리가 지원할 서로 다른 3 가지 종류의 컴포넌트들을 볼수 있다.</p>
<ul>
<li><code>b</code>,<code>p</code> 그리고 <code>i</code> 를 위한 fiber 들은 <strong>host components</strong> 대표한다. 이들의 식별자는 tag 에 <code>HOST_COMPONENT</code> 라고 지칭 할것이다. <code>type</code>은 string(html element 의 태그) 이 될것이다. <code>props</code>는 속성값과 해당 element 의 이벤트 리스너가 되겠다.</li>
<li><code>Foo</code> fiber 는 <strong>class component</strong> 를 대표한다. 이것의 <code>tag</code>는 <code>CLASS_COMPONENT</code> 가 될 것이고, <code>type</code>은 유저가 정의한 <code>Didact.Component</code>를 상속한 <code>class</code> 의 참조값이 될것이다.</li>
<li><code>div</code>를 위한 fiber 는 <strong>host root</strong> 를 대표한다. 이것은 위에서 언급한 host component 과 유사한데 그 이유는 DOM element 를 지니고 있기 때문이다. 그러나 이 host root 는 트리의 root 가 되어서 특별하게 다뤄질 것이다. <code>tag</code>는 <code>HOST_ROOT</code>가 될것이다. 이 fiber 의 stateNod 는 <code>Didact.render()</code>로 전달 받은 DOM node 이다.</li>
</ul>
<p>다른 중요한 프로퍼티는 <code>alternate</code> 이다. 이 <code>alternate</code> 가 필요한 이유는 대부분의 시간동안에 두가지의 fiber tree 를 가져야 하기 때문입니다.
<strong>한가지 tree 는 우리가 이미 render 한 DOM 에 관한 것이고, 이것을 우린 current tree 또는 old tree 라고 부를 것이다. 또 다른 하나는 우리가 <code>setState()</code> 또는 <code>Didact.render()</code> 호출을 통해서 새로운 update 작업을 할때 생성되는 tree 이다. 이것을 우린 <em>work-in-progress tree</em> 라고 부를 것입니다.</strong></p>
<p>work-in-progress tree 는 old tree 와 어떤 fiber를 공유하지 않습니다. 일단 work-in-progress tree 를 완성하고나면 DOM 을 변화 시키고, 다시 이 work-in-progress tree 가 old tree 가됩니다.</p>
<p>따라서 <code>alternate</code>는 work-in-progress tree fiber 들을 old tree 에 상응하는 fiber 들과 연결하기 위해 사용합니다. fiber 와 그것의 <code>alternate</code>는 같은 <code>tag</code>, <code>type</code> 그리고 <code>stateNode</code>를 공유합니다. 때론 새로운 rendering 작업이 있을떈 fiber 들은 <code>alternate</code>를 안가지고 있을 수 있다.</p>
<p>마지막으로, <code>effects</code>리스트와 <code>effectTag</code>를 갖습니다. work-in-progress tree 안에서 DOM 이 변화할 필요가 있는 fiber 를 찾았을때 <code>effectTag</code>를 <code>PLACEMENT</code>, <code>UPDATE</code> 또는 <code>DELETION</code>으로 설정합니다. 모든 DOM 변화를 손쉽게 처리하기 위해 <code>effectTag</code>를 가지고 있는 모든 fiber 들의 목록(fiber 하위 트리로부터 나온 fiber 들)을 <code>effects</code>에 유지합니다.</p>
<h3>Didact call hierarchy</h3>
<p>우리가 작성하려고하는 코드의 흐름을 이해하려면이 다이어그램을 살펴보십시오.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber02-cb798eaf0c4d3390f2b386a01f152b71-6dadd.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 80.65068493150686%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAABpElEQVQoz42TD2+DIBDF/f7fcFvm1k5R/NeKAoKg+7U2jTHNsktL4I5373F3Jus/TClV17UQ4nK57P0Jf2unrrtqY7F9LISAZ1nXZVmMMX3fxxiP4EvXFuePMEGguPeMgSykDDH2w8CmKIpxHI/gUanq8609f7VSHgQHrVVRNOfzrJRzbp/6AVZ9Lz/T+uu7zvN9jItRqblpbFWtfT9ZOwzDEfyH+Xmu2lZIqaeH/QVe7rb3UKdKyoNzO75gJkCdvffwsLler1LKeZ55Mx42OF+DqXBVVbSUynOJxtLhPM+7rgNJRjxZluGkbUcwYfBIpTZQkQJY27b4NzaYh7txfCGbMOnD3UivtQb/fBI/kNaYF7IBIBud0HJk5cF4nsOnrc3LsrnPafIs0iYShVBtmjf9qGC91WlZkBHr2mTZJAQKk3WJQL1zZckIyjRNy7Lc5pR3kovj6XRiHY3xjMrPjxfCZxltuDFT+2HUId46BAkv3PqEMcwImZx7tMr7cffxJK5ObZWOxXvoxeR80zR0Aqkwk4U9nDTGTtOi9SylEYIVVYB/AW9hoM7D2JM/AAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber02.png"
        title=""
        src="/ho_blog/static/fiber02-cb798eaf0c4d3390f2b386a01f152b71-6dadd.png"
        srcset="/ho_blog/static/fiber02-cb798eaf0c4d3390f2b386a01f152b71-97f41.png 148w,
/ho_blog/static/fiber02-cb798eaf0c4d3390f2b386a01f152b71-94c01.png 295w,
/ho_blog/static/fiber02-cb798eaf0c4d3390f2b386a01f152b71-6dadd.png 584w"
        sizes="(max-width: 584px) 100vw, 584px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p><code>render()</code> 및 <code>setState()</code> 에서 시작하여 <code>commitAllWork()</code> 에서 끝나는 흐름을 따릅니다.</p>
<h3>Old code</h3>
<p>대부분의 코드를 재 작성해야 한다고 이야기 했었었다. 하지만 먼저 수정하지 않을 코드가 있는지 살펴봅시다.</p>
<p>트랜스파일된 JSX 가 사용하는 함수인 createElement 함수를 작성했습니다. 우리가 작성한 <code>createElement()</code> 함수는 변할 필요가 없다. 우린 계속 동일한 element 들을 사용할 것이기 때문이다. 여기서 element 는 <code>type</code>,<code>props</code> 그리고 <code>children</code>을 가진 평범한 자바스크립트 객체였다.</p>
<p>우린 노드의 DOM 프로퍼티를 갱신 하기 위해 <code>updateDomProperties()</code> 도 작성했었다. 또 DOM element 들을 생성하기 위해 <code>createDomElement()</code> 함수도 추출했습니다. 이 두 함수 모두 <a href="https://gist.github.com/pomber/c63bd22dbfa6c4af86ba2cae0a863064">이곳</a>에서 볼수 있습니다.</p>
<p>base class 인 <code>Component</code> 도 작성했었습니다. 여기서 <code>setState()</code>가 <code>scheduleUpdate()</code> 를 호출하게 만들고 <code>createInstance()</code> 가 instance 에 fiber 를 참조하도록 만듭시다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>class&nbsp;Component&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;constructor(props)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.props&nbsp;=&nbsp;props&nbsp;||&nbsp;{}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;this.state&nbsp;||&nbsp;{}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;setState(partialState)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;scheduleUpdate(this,&nbsp;partialState)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;createInstance(fiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;instance&nbsp;=&nbsp;new&nbsp;fiber.type(fiber.props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;instance.__fiber&nbsp;=&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;instance</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>이 코드로 시작하고 나머지는 처음부터 다시 작성하지 않습니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber03-925fc0565fc5ec71cb75ccc91b85eb95-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAhUlEQVQI12WOwQoDIQxE9/8/0IuKoOtN0JVGG6O26dqWlp1DiGRmfNvj1Jzzd67lqlJKSqm1tp4b+7z3WmvnXM4ZAIjoGrsB3BFjSvu+I+I7PMYwxgghpJTWWm5RSrEjhLBaFgUhwnHkGGut48P1+plNTMKz9843Lm6n/uDZVgpxkuiL9gTP0+hEPHz+hQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber03.png"
        title=""
        src="/ho_blog/static/fiber03-925fc0565fc5ec71cb75ccc91b85eb95-fb8a0.png"
        srcset="/ho_blog/static/fiber03-925fc0565fc5ec71cb75ccc91b85eb95-1a291.png 148w,
/ho_blog/static/fiber03-925fc0565fc5ec71cb75ccc91b85eb95-2bc4a.png 295w,
/ho_blog/static/fiber03-925fc0565fc5ec71cb75ccc91b85eb95-fb8a0.png 590w,
/ho_blog/static/fiber03-925fc0565fc5ec71cb75ccc91b85eb95-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p><code>Component</code> 클래스와 <code>createElement()</code> 외에도 <code>render()</code>와 <code>setState()</code>라는 두 개의 공용 함수가 있으며 <code>setState()</code>가 <code>scheduleUpdate()</code>를 호출하는 것을 보았습니다.
<code>render()</code> 및 <code>scheduleUpdate()</code> 도 비슷합니다. 이 두 함수들은 새 업데이트 할것을 받고 대기열(큐)에 넣습니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>//&nbsp;Fiber&nbsp;tags</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;HOST_COMPONENT&nbsp;=&nbsp;&#39;host&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;CLASS_COMPONENT&nbsp;=&nbsp;&#39;class&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;HOST_ROOT&nbsp;=&nbsp;&#39;root&#39;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;Global&nbsp;state</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;updateQueue&nbsp;=&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>let&nbsp;nextUnitOfWork&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>let&nbsp;pendingCommit&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;render&nbsp;함수</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;아래서&nbsp;render&nbsp;함수라는건&nbsp;이&nbsp;함수를&nbsp;가리킴</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;이&nbsp;render는&nbsp;처음에&nbsp;딱&nbsp;한번&nbsp;실행함.</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;render(elements,&nbsp;containerDom)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;updateQueue.push({</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;HOST_ROOT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;dom:&nbsp;containerDom,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;newProps:&nbsp;{&nbsp;children:&nbsp;elements&nbsp;},</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;requestIdleCallback(performWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;scheduleUpdate(instance,&nbsp;partialState)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;updateQueue.push({</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;CLASS_COMPONENT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance:&nbsp;instance,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;partialState:&nbsp;partialState,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;requestIdleCallback(performWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>updateQueue</code> 배열을 사용해서 보류중인 update 추적할 것입니다. 매 <code>render()</code> 또는 <code>scheduleUpdate()</code> 호출은 새로운 업데이트를 <code>updateQueue</code> 큐에 넣는다.
각 업데이트들의 업데이트 정보는 다르고 이것을 우리가 나중에 <code>resetNextUnitOfWork()</code> 에서 어떻게 사용할지 볼수 있을것입니다.</p>
<p>업데이트를 큐에 넣고 나서, <code>performWork()</code>에 대한 지연 호출을 트리거합니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber04-f7dc85e94c54deaebdbe6e0fc381b0a2-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAhUlEQVQI12WOSw6FIBAEuf8ZCWwQDGieAeU76OtA4sZadQo6PewZ9N5nuAfPh5uoeF9DiOeZUpqSEZGUclkWrTXnXCllrfXef/s/cByN6F1ipRRjDDpCCDlY17XW+h6Sc76uC2bfNuccAiowWGXzBxQNcFJr7V3DCP5B4inGiAyDHEJA5Q+XkefP5rfyDAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber04.png"
        title=""
        src="/ho_blog/static/fiber04-f7dc85e94c54deaebdbe6e0fc381b0a2-fb8a0.png"
        srcset="/ho_blog/static/fiber04-f7dc85e94c54deaebdbe6e0fc381b0a2-1a291.png 148w,
/ho_blog/static/fiber04-f7dc85e94c54deaebdbe6e0fc381b0a2-2bc4a.png 295w,
/ho_blog/static/fiber04-f7dc85e94c54deaebdbe6e0fc381b0a2-fb8a0.png 590w,
/ho_blog/static/fiber04-f7dc85e94c54deaebdbe6e0fc381b0a2-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>const&nbsp;ENOUGH_TIME&nbsp;=&nbsp;1&nbsp;//&nbsp;milliseconds</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;render&nbsp;또는&nbsp;scheduleUpdate&nbsp;에서</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;requestIdleCallback(performWork)&nbsp;로&nbsp;호출함.</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;performWork(deadline)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;workLoop(deadline)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(nextUnitOfWork&nbsp;||&nbsp;updateQueue.length&nbsp;&gt;&nbsp;0)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;requestIdleCallback(performWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;nextUnitOfWork은&nbsp;처음에&nbsp;null로&nbsp;셋팅되어&nbsp;있음.</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;workLoop(deadline)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(!nextUnitOfWork)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;여기서&nbsp;처음에&nbsp;nextUnitOfWork&nbsp;을&nbsp;셋팅함.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;resetNextUnitOfWork()</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(nextUnitOfWork&nbsp;&amp;&amp;&nbsp;deadline.timeRemaining()&nbsp;&gt;&nbsp;ENOUGH_TIME)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;nextUnitOfWork&nbsp;=&nbsp;performUnitOfWork(nextUnitOfWork)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(pendingCommit)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;commitAllWork(pendingCommit)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>여기 우리가 앞서 보았던 <code>performUnitOfWork()</code> 패턴을 사용합니다.</p>
<p><code>requestIdleCallback()</code>은 deadline 파라미터를 함께 가진 타겟 함수를 호출합니다. <code>performWork()</code> deadline 을 받아서 <code>workLoop()</code> 로 전달해줍니다. <code>workLoop()</code> returns 후에, <code>performWork()</code> 작업 준비가 되었는지 체크를 합니다. 만약 준비가 됬다면, 자기 자신을 새로운 지연 호출로 스케줄링 시킵니다.</p>
<p><code>workLoop()</code> 은 시간을 주시하는 함수입니다. 만약 deadline 이 너무 가깝다면(마감시간), 루프 작업은 멈추고 다음 업데이트 해야할 작업을 남겨둡니다. 그래서 다시 다음 타임에 재개 될 수 있도록 합니다.</p>
<blockquote>
<p><code>deadline.timeRemaining()</code>이 다른 작업 단위를 실행하기에 충분한지 아닌지 확인하기 위해 ENOUGH_TIME (1ms 상수, React 와 동일)을 사용합니다. <code>performUnitOfWork()</code>가 그 이상을 수행하면 마감 시간이 초과 될것입니다. deadline은 브라우저의 제안 일 뿐이므로 몇 밀리 초 동안 초과실행 하는것은 그렇게 나쁘지 않습니다.</p>
</blockquote>
<p><code>performUnitOfWork()</code>는 업데이트를위한 work-in-progress 트리를 만들고 DOM 에 적용해야 할 변경 사항을 남겨둡니다. <strong>이것은 한 번에 한 fiber 씩 점진적으로 이루어질 것입니다.</strong></p>
<p><code>performUnitOfWork()</code>가 현재 업데이트에 대한 모든 작업을 완료하면 null 을 반환하고 보류중인 DOM 변경 사항을 <code>pendingCommit</code>에 남겨 둡니다. 마침내 <code>commitAllWork()</code>는 <code>pendingCommit</code> 에서 <code>effects</code>를 받아 DOM 을 변경합니다.</p>
<p><code>commitAllWork()</code>는 루프 외부에서 호출됩니다. <code>performUnitOfWork()</code>에서 수행 된 작업은 DOM 을 변경하지 않으므로 분할하는 것이 좋습니다. 반면에, <code>commitAllWork()</code>는 DOM 을 돌연변이시킬 것이고 일관성없는 UI 를 피하기 위해 한번에 모두 완료되어야합니다.</p>
<p>우리는 여전히 어디서 <code>nextUnitOfWork</code>를 처음으로 불러오는지 보지 못했습니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber05-0e1c8186d35e3df92e401236f52f1908-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAbUlEQVQI142OCwrAIAxDvf8tBUUmguDq37oFe4AtUAhpHq16fquUUmtda+29JVGYnDMRpZTuoxACHfXe0QMAw8xSgwEvicLaGKO19t4750Baa68jtMcYMUYwAOQyH2E151Sf37bW5A5IeAnl/xdhZulTyLyzoAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber05.png"
        title=""
        src="/ho_blog/static/fiber05-0e1c8186d35e3df92e401236f52f1908-fb8a0.png"
        srcset="/ho_blog/static/fiber05-0e1c8186d35e3df92e401236f52f1908-1a291.png 148w,
/ho_blog/static/fiber05-0e1c8186d35e3df92e401236f52f1908-2bc4a.png 295w,
/ho_blog/static/fiber05-0e1c8186d35e3df92e401236f52f1908-fb8a0.png 590w,
/ho_blog/static/fiber05-0e1c8186d35e3df92e401236f52f1908-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>업데이트를 받아서 첫 번째 <code>nextUnitOfWork</code>로 변환하는 함수는 <code>resetNextUnitOfWork()</code> 입니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>//&nbsp;render&nbsp;할때나&nbsp;scheduleUpdate&nbsp;호출될때&nbsp;updateQueue에&nbsp;update를&nbsp;넣게&nbsp;되는데</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;이때&nbsp;처음으로&nbsp;updateQueue에&nbsp;있는&nbsp;update&nbsp;를&nbsp;꺼내오는&nbsp;함수.</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;update&nbsp;를&nbsp;꺼내와서&nbsp;nextUnitOfWork&nbsp;의&nbsp;fiber를&nbsp;만들어줌.</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;resetNextUnitOfWork()&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;update&nbsp;=&nbsp;updateQueue.shift()</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(!update)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;Copy&nbsp;the&nbsp;setState&nbsp;parameter&nbsp;from&nbsp;the&nbsp;update&nbsp;payload&nbsp;to&nbsp;the&nbsp;corresponding&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;여기서&nbsp;instance는&nbsp;component의&nbsp;public&nbsp;instance를&nbsp;가리킴.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;partialState&nbsp;이것은&nbsp;update할&nbsp;새로운&nbsp;값&nbsp;(setState로&nbsp;넘어오는&nbsp;인자)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(update.partialState)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;update.instance.__fiber.partialState&nbsp;=&nbsp;update.partialState</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;그런&nbsp;다음&nbsp;old&nbsp;fiber&nbsp;tree의&nbsp;root를&nbsp;찾습니다.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;root&nbsp;=</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;update.from&nbsp;==&nbsp;HOST_ROOT</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;update.dom._rootContainerFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;getRoot(update.instance.__fiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;새로운&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;새로운&nbsp;work-in-progress&nbsp;tree의&nbsp;root</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;update에&nbsp;dom값이&nbsp;있으면&nbsp;처음&nbsp;render&nbsp;함수&nbsp;호출하는거</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;update에&nbsp;newProps&nbsp;값이&nbsp;있으면&nbsp;처음&nbsp;render&nbsp;함수&nbsp;호출하는거.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;nextUnitOfWork&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;tag:&nbsp;HOST_ROOT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;stateNode:&nbsp;update.dom&nbsp;||&nbsp;root.stateNode,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;props:&nbsp;update.newProps&nbsp;||&nbsp;root.props,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;alternate:&nbsp;root,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;getRoot(fiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;node&nbsp;=&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(node.parent)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.parent</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;node</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>resetNextUnitOfWork()</code>는 대기열에서 첫 번째 업데이트를 가져 와서 시작합니다.</p>
<p>update 객체에 <code>partialState</code>가 있다면 컴포넌트 인스턴스에 속해있는 fiber 에 그것을 저장 시켜 놓습니다. 그래서 나중에 컴포넌트의 <code>render()</code>를 호출 할 때 사용할 수 있습니다.</p>
<p>그런 다음 old fiber tree 의 root 를 찾습니다. 처음 호출되는 <code>render()</code>함수로 update 객체들이 넘어왔을 경우에는 루트 fiber 가 없으므로 <code>root</code>가 <code>null</code>이 됩니다. <code>render()</code>에 대한 후속 호출에서 오는 경우 DOM 노드의 <code>_rootContainerFiber</code> 속성에서 루트를 찾을 수 있습니다. 그리고 업데이트가 <code>setState()</code>에서 오는 경우에는, 부모가없는 fiber 가 발견 될 때까지 인스턴스 fiber 에서 위로 이동해야합니다.</p>
<p>그런 다음 <code>nextUnitOfWork</code>에 새 fiber 를 할당합니다. <strong>이 fiber 는 새로운 work-in-progress tree 의 root 입니다.</strong></p>
<p>만약 old root 가 없다면(이미 그려진 DOM 이 없다면), <code>stateNode</code>(component instance)는 <code>render()</code> 호출할때 매개 변수로 받은 DOM 노드(containerDom)입니다. <code>props</code> 는 update 객체의 <code>newProps</code>가됩니다 : 여기서 <code>newProps</code>는 element(render()의 element 매개변수)들을 가지고있는 children 프로퍼티를 가진 객체이다(위 <code>render</code> 함수 참고). <code>alternate</code>은 null 이 될 것입니다. 왜냐하면 처음으로 호출되는 <code>render</code> 이기 때문에 루트 fiber 가 없다.</p>
<p>만약 old root 가 있다면 <code>stateNode</code>는 이전 루트의 DOM 노드가됩니다. <code>props</code>는 다시 newProps 가 null 이 아니면 <code>newProps</code>로 할당되고 그렇지 않으면 이전 루트에서 <code>props</code> 복사합니다. <code>alternate</code>는 이전 루트가됩니다.</p>
<p>이제 우리는 work-in-progress tree 의 root 을 가지고 나머지 부분을 만들기 시작합시다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber06-a3d4baef4ba4a6182d4a51b4d1a88e17-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAbUlEQVQI142PSwrAIAxEvf8lXUkRQfAT4r8dEui2fYswTGaImvs3zNxaW2udc9QxULXWnDMRpZRUhBBgllKQnnOOMdDR2BJ673tvg5219hKcc5gxRhXee/RZQDoKaKKGAyiaz9eSoJch3i/AeQAd/uiNdYwOrwAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber06.png"
        title=""
        src="/ho_blog/static/fiber06-a3d4baef4ba4a6182d4a51b4d1a88e17-fb8a0.png"
        srcset="/ho_blog/static/fiber06-a3d4baef4ba4a6182d4a51b4d1a88e17-1a291.png 148w,
/ho_blog/static/fiber06-a3d4baef4ba4a6182d4a51b4d1a88e17-2bc4a.png 295w,
/ho_blog/static/fiber06-a3d4baef4ba4a6182d4a51b4d1a88e17-fb8a0.png 590w,
/ho_blog/static/fiber06-a3d4baef4ba4a6182d4a51b4d1a88e17-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>//&nbsp;wipFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;tag:&nbsp;HOST_ROOT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;stateNode:&nbsp;update.dom&nbsp;||&nbsp;root.stateNode,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;props:&nbsp;update.newProps&nbsp;||&nbsp;root.props,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;alternate:&nbsp;root,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;performUnitOfWork(wipFiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;beginWork(wipFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(wipFiber.child)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;wipFiber.child</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;No&nbsp;child,&nbsp;we&nbsp;call&nbsp;completeWork&nbsp;until&nbsp;we&nbsp;find&nbsp;a&nbsp;sibling</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;uow&nbsp;=&nbsp;wipFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(uow)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;completeWork(uow)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uow.sibling)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Sibling&nbsp;needs&nbsp;to&nbsp;beginWork</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;uow.sibling</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;uow&nbsp;=&nbsp;uow.parent</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>performUnitOfWork()</code>는 진행중인 작업 트리를 탐색합니다.</p>
<p><code>beginWork()</code>를 호출한다. —이것은 새로운 fiber 의 children 을 만들기 위한 작업이다.— 그리고 나서 첫번째 child을 리턴한다. 그리고나서 그것을  <code>nextUnitOfWork</code> 에 대입한다.</p>
<p>만약 어떤 child 도 없다면, <code>completeWork()</code>를 호출하고 <code>nextUnitOfWork</code>가 될 <code>sibling</code>을 리턴한다.</p>
<p>만약 <code>sibling</code>가 없다면, parents 로 올라가서 해당 parents 를 인자로 <code>completeWork()</code>를 호출한다. 이 작업은 <code>sibling</code>을 찾을때 또는 root 에 도달했을 때까지 반복한다.</p>
<p><code>performUnitOfWork()</code>를 여러 번 호출하면 자식(children)이 없는 파이버를 찾을 때까지 각 파이버의 첫번째 자식의 자식들을 생성하면서 계속해서 트리의 하위로 내려갑니다. 그리고 오른쪽으로 옮겨서 siblings 에도 같은 작업을 수행합니다. 그리고 다시 위로 올라와서 같은 작업을 수행합니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber07-d71ef97e3317e6cc9c4d8ee5a383b830-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAlElEQVQI122Oyw6EIAxF/f9/NIagGQMmgggUfMyckc0spovm5rY9t91938dxnOdZSkFc1/X+V/g5ZxGpte77jsDscKdpGsdRaz3Ps7WWJSj1qV/cuq4pJQSdsO8xyUqpvu9BcG+MQQ/DAA7He8/etm2vpzgjFn9ZFtAdADYYt0HrzrkYY3uvSJacnfckAwohtBeKyAfr9OT+nGcDnwAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber07.png"
        title=""
        src="/ho_blog/static/fiber07-d71ef97e3317e6cc9c4d8ee5a383b830-fb8a0.png"
        srcset="/ho_blog/static/fiber07-d71ef97e3317e6cc9c4d8ee5a383b830-1a291.png 148w,
/ho_blog/static/fiber07-d71ef97e3317e6cc9c4d8ee5a383b830-2bc4a.png 295w,
/ho_blog/static/fiber07-d71ef97e3317e6cc9c4d8ee5a383b830-fb8a0.png 590w,
/ho_blog/static/fiber07-d71ef97e3317e6cc9c4d8ee5a383b830-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>//&nbsp;wipFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;tag:&nbsp;HOST_ROOT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;stateNode:&nbsp;update.dom&nbsp;||&nbsp;root.stateNode,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;props:&nbsp;update.newProps&nbsp;||&nbsp;root.props,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;&nbsp;&nbsp;alternate:&nbsp;root,</span></span></div><div class="line"><span class="text plain null-grammar"><span>//&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;beginWork(wipFiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(wipFiber.tag&nbsp;==&nbsp;CLASS_COMPONENT)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateClassComponent(wipFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateHostComponent(wipFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;updateHostComponent(wipFiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(!wipFiber.stateNode)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;wipFiber.stateNode&nbsp;=&nbsp;createDomElement(wipFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;newChildElements&nbsp;=&nbsp;wipFiber.props.children</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;reconcileChildrenArray(wipFiber,&nbsp;newChildElements)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;updateClassComponent(wipFiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;instance&nbsp;=&nbsp;wipFiber.stateNode</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Call&nbsp;class&nbsp;constructor</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;wipFiber.stateNode&nbsp;=&nbsp;createInstance(wipFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(wipFiber.props&nbsp;==&nbsp;instance.props&nbsp;&amp;&amp;&nbsp;!wipFiber.partialState)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;need&nbsp;to&nbsp;render,&nbsp;clone&nbsp;children&nbsp;from&nbsp;last&nbsp;time</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;cloneChildFibers(wipFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;instance.props&nbsp;=&nbsp;wipFiber.props</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;instance.state&nbsp;=&nbsp;Object.assign({},&nbsp;instance.state,&nbsp;wipFiber.partialState)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;wipFiber.partialState&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;newChildElements&nbsp;=&nbsp;wipFiber.stateNode.render()</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;reconcileChildrenArray(wipFiber,&nbsp;newChildElements)</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>beginWork()</code>는 두가지를 합니다:</p>
<ul>
<li><code>stateNode</code>를 가지고 있지 않다면 생성해줍니다.</li>
<li>component children 을 가져와 <code>reconcileChildrenArray()</code>에 그것들을 넘겨준다.</li>
</ul>
<p>두가지 타입의 component 를 우리가 다루기 때문에 우리는 2 가지로 나눠야 한다. <code>updateHostComponent()</code> 와 <code>updateClassComponent()</code> 이다.</p>
<p><code>updateHostComponent()</code>는 host component 들과 root component 를 다룬다. 그것은 필요하다면 새로운 DOM 을 만들어내고 <strong>fiber props 에서 나온 child element 들을 이용해서 <code>reconcileChildrenArray()</code>를 호출한다.</strong></p>
<p><code>updateClassComponent()</code>는 class component instance 들을 다룬다. 그것은 필요하다면 component 의 생성자를 호출해서 instance 를 만들어낸다. <strong>instance 의 props 와 state 를 업데이트를 하고 <code>render()</code>를 호출해서 새로운 children 을 얻는다.</strong></p>
<p><code>updateClassComponent()</code> 또한 <code>render()</code>를 호출하는것이 맞는지 확인합니다. 이것은 <code>shouldComponentUpdate()</code>의 간단한 버전이다. 만약 re-render 할 필요가 없어 보인다면, 어떠한 reconciliation 없이 현재 sub-tree 를 work-in-progress 트리로 복사합니다.</p>
<p>이제 <code>newChildElements</code>를 가지고있고, work-in-grogress fiber 를 위한 child fiber 들을 만들 준비가 되었습니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber08-f3e48d0a3449fc30707b57a88b80fe12-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAcklEQVQI142O2Q5DIQhE/f9vrXEBFAVt52r62vQkknFYw/s/9t7MbGbQrTVVhQhwc84ppXyIMZZSXodr3lIi6r27+5xTRGBCP816QE6/QCP9RBG8OQYx44vN6MQgRDcLP29dS8kkLR86xt1ca8VpGLzdP1qG6VNDcdjaAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber08.png"
        title=""
        src="/ho_blog/static/fiber08-f3e48d0a3449fc30707b57a88b80fe12-fb8a0.png"
        srcset="/ho_blog/static/fiber08-f3e48d0a3449fc30707b57a88b80fe12-1a291.png 148w,
/ho_blog/static/fiber08-f3e48d0a3449fc30707b57a88b80fe12-2bc4a.png 295w,
/ho_blog/static/fiber08-f3e48d0a3449fc30707b57a88b80fe12-fb8a0.png 590w,
/ho_blog/static/fiber08-f3e48d0a3449fc30707b57a88b80fe12-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>이것이 이 library 의 심장입니다. work-in-progress 트리가 커지며 커밋 단계에서 DOM 에 대해 어떤 변경 작업을 수행할지 결정합니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>//&nbsp;Effect&nbsp;tags</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;PLACEMENT&nbsp;=&nbsp;1</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;DELETION&nbsp;=&nbsp;2</span></span></div><div class="line"><span class="text plain null-grammar"><span>const&nbsp;UPDATE&nbsp;=&nbsp;3</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;arrify(val)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;val&nbsp;==&nbsp;null&nbsp;?&nbsp;[]&nbsp;:&nbsp;Array.isArray(val)&nbsp;?&nbsp;val&nbsp;:&nbsp;[val]</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;reconcileChildrenArray(wipFiber,&nbsp;newChildElements)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;elements&nbsp;=&nbsp;arrify(newChildElements)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;index&nbsp;=&nbsp;0</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;oldFiber&nbsp;=&nbsp;wipFiber.alternate&nbsp;?&nbsp;wipFiber.alternate.child&nbsp;:&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;newFiber&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;//&nbsp;새롭게&nbsp;들어온&nbsp;element&nbsp;또는&nbsp;oldFiber가&nbsp;없을때까지&nbsp;반복</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(index&nbsp;&lt;&nbsp;elements.length&nbsp;||&nbsp;oldFiber&nbsp;!=&nbsp;null)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;prevFiber&nbsp;=&nbsp;newFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;element&nbsp;=&nbsp;index&nbsp;&lt;&nbsp;elements.length&nbsp;&amp;&amp;&nbsp;elements[index]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;sameType&nbsp;=&nbsp;oldFiber&nbsp;&amp;&amp;&nbsp;element&nbsp;&amp;&amp;&nbsp;element.type&nbsp;==&nbsp;oldFiber.type</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sameType)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newFiber&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;oldFiber.type,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag:&nbsp;oldFiber.tag,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stateNode:&nbsp;oldFiber.stateNode,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props:&nbsp;element.props,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent:&nbsp;wipFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternate:&nbsp;oldFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partialState:&nbsp;oldFiber.partialState,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;effectTag:&nbsp;UPDATE,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(element&nbsp;&amp;&amp;&nbsp;!sameType)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newFiber&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;element.type,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag:</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof&nbsp;element.type&nbsp;===&nbsp;&#39;string&#39;&nbsp;?&nbsp;HOST_COMPONENT&nbsp;:&nbsp;CLASS_COMPONENT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props:&nbsp;element.props,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent:&nbsp;wipFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;effectTag:&nbsp;PLACEMENT,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(oldFiber&nbsp;&amp;&amp;&nbsp;!sameType)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFiber.effectTag&nbsp;=&nbsp;DELETION</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wipFiber.effects&nbsp;=&nbsp;wipFiber.effects&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wipFiber.effects.push(oldFiber)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(oldFiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldFiber&nbsp;=&nbsp;oldFiber.sibling</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(index&nbsp;==&nbsp;0)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wipFiber.child&nbsp;=&nbsp;newFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(prevFiber&nbsp;&amp;&amp;&nbsp;element)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevFiber.sibling&nbsp;=&nbsp;newFiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;index++</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>시작하기 전에 <code>newChildElements</code>가 배열인지 확인하십시오. (이전의 reconciliation 알고리즘과 달리 <code>reconcileChildrenArray</code>는 항상 자식 배열과 함께 작동합니다. 즉, 이제 component 의 <code>render()</code> 함수에서 배열을 반환 할 수 있습니다.)</p>
<p>그 후에 old fiber tree 의 children 들을 새로운 element 와 비교하기 시작합니다. (fiber 와 element 를 비교하는 것이다.) old fiber tree 의 children 들은 <code>wipFiber.alternate</code> 의 children 이다. 새로운 element 들은 <code>wipFiber.props.children</code> 에서 얻어 오거나 또는 <code>wipFiber.stateNode.render()</code> 호출해서 얻어온 것입니다.</p>
<p>reconciliation 알고리즘은 첫번째 old fiber(<code>wipFiber.alternate.child</code>)와 첫번째 child element(<code>element[0]</code>) 를 일치 시키고, 두번째 old fiber(<code>wipFiber.alternate.child.sibling</code>) 두번째 child element(<code>element[1]</code>)도 반복합니다. 각각 oldFiber-element 쌍을 이루게 합니다.</p>
<ul>
<li>
<p>만약 oldFiber 와 element 가 타입이 같다면, 이것은 좋은 소식입니다, 이것은 기존의 stateNode 를 유지할수 있다는 뜻이다. 우리는 new fiber 를 예전거 기반에서 생성합니다. <code>UPDATE</code>를 <code>effectTag</code>에 추가시킨다. 그리고 새로운 fiber 를 work-in-progress tree 에 덧붙입니다.</p>
</li>
<li>
<p>만약 element 의 type 이 oldFiber 와 다르거나 oldFiber 가 없다면(왜냐하면 기존 자식들보다 새로운 자식들을 많이 가지고 있는 경우), 우리가 가지고 있는 element 정보를 가지고 새로운 fiber 를 생성합니다. 이 새로운 fiber 는 <code>alternate</code> 와 <code>stateNode</code>를 가지고 있지 않는다. (<code>stateNode</code>는 <code>beginWork()</code>에서 생성됩니다.) 이 fiber 의 <code>effectTag</code> 는 <code>PLACEMENT</code> 입니다.</p>
</li>
<li>
<p>만약 oldFiber 와 element 가 다른 type 이거나 이 oldFiber 를 위한 어떠한 element 도 없는 경우(왜냐하면 기존 자식들이 새로운 자식들 보다 많이 가지고 있기 때문) oldFiber 는 DELETION 태그를 붙입니다. 이 fiber 는 작업 중(work-in-progress) 트리의 일부가 아니기 때문에, 그것을 추적할 수 없게끔 wipFiber.effets 목록에 추가해야 합니다.</p>
</li>
</ul>
<blockquote>
<p>리액트와는 달리 재조정을 위해 keys 를 사용하지 않으므로, 이전 위치에서 벗어난 자식이 있는지 알 수 없습니다.</p>
</blockquote>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber09-ac8503ac4e5f378f55ab8d7bfe6dfbd8-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAfklEQVQI142O2woDIQxE/f/vlAq6FhZvWRNtT7fvpQMJk2RmiHv9h713rVVV4b13EYE4qrXG4bxRSsk501Gw3zeQIhhjrLXmnHBOZuaYj+Pw3ocQYowpJcgDhMDedOq8LhFy8WAgiFyCTNX9/HXZOGd9LpVSPq99zTjVbJu9ASun6Jpvt5FhAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber09.png"
        title=""
        src="/ho_blog/static/fiber09-ac8503ac4e5f378f55ab8d7bfe6dfbd8-fb8a0.png"
        srcset="/ho_blog/static/fiber09-ac8503ac4e5f378f55ab8d7bfe6dfbd8-1a291.png 148w,
/ho_blog/static/fiber09-ac8503ac4e5f378f55ab8d7bfe6dfbd8-2bc4a.png 295w,
/ho_blog/static/fiber09-ac8503ac4e5f378f55ab8d7bfe6dfbd8-fb8a0.png 590w,
/ho_blog/static/fiber09-ac8503ac4e5f378f55ab8d7bfe6dfbd8-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p><code>updateClassComponent()</code> 는 재조정을 하는 대신 지름길로 old fiber 하위 트리를 work-in-progress 트리로 복제하는 특별한 경우가 있습니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;cloneChildFibers(parentFiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;oldFiber&nbsp;=&nbsp;parentFiber.alternate</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(!oldFiber.child)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;oldChild&nbsp;=&nbsp;oldFiber.child</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;prevChild&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(oldChild)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;newChild&nbsp;=&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;oldChild.type,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag:&nbsp;oldChild.tag,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stateNode:&nbsp;oldChild.stateNode,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props:&nbsp;oldChild.props,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partialState:&nbsp;oldChild.partialState,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternate:&nbsp;oldChild,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent:&nbsp;parentFiber,</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(prevChild)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevChild.sibling&nbsp;=&nbsp;newChild</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parentFiber.child&nbsp;=&nbsp;newChild</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;prevChild&nbsp;=&nbsp;newChild</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;oldChild&nbsp;=&nbsp;oldChild.sibling</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>cloneChildFibers()</code> 는 각 <code>wipFiber.alternate</code> 자식들(children)을 복제하고 work-in-progress 트리에 추가합니다. 아무것도 변경하지 않아도 되므로 어떠한 <code>effectTag</code> 도 추가할 필요가 없습니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber10-46742e113ecd9b82b1fbfb962b49a675-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAeklEQVQI131OMQ7EIAzj/29kQwLEgg4IgQa4uiB1rIfIcmLH6v+JtVatlZlFBKSUIhtEhKlwATWllHPGLsaICWXOecyttd77GIM3XvExgznntNbee2utMSaEgAjs3s8wg/w2TiOIMob6KIx41EFDvIX/VANfzFeMk+gGTJ7pA4j0X2oAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber10.png"
        title=""
        src="/ho_blog/static/fiber10-46742e113ecd9b82b1fbfb962b49a675-fb8a0.png"
        srcset="/ho_blog/static/fiber10-46742e113ecd9b82b1fbfb962b49a675-1a291.png 148w,
/ho_blog/static/fiber10-46742e113ecd9b82b1fbfb962b49a675-2bc4a.png 295w,
/ho_blog/static/fiber10-46742e113ecd9b82b1fbfb962b49a675-fb8a0.png 590w,
/ho_blog/static/fiber10-46742e113ecd9b82b1fbfb962b49a675-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p><code>performUnitOfWork()</code> 에서 wipFiber 가 새로운 자식들(children)을 가지고 있지 않거나 이미 모든 자식들이 이미 작업을 완료 했을 때, <code>completeWork()</code>를 호출합니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;completeWork(fiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(fiber.tag&nbsp;==&nbsp;CLASS_COMPONENT)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;fiber.stateNode.__fiber&nbsp;=&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(fiber.parent)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;childEffects&nbsp;=&nbsp;fiber.effects&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;thisEffect&nbsp;=&nbsp;fiber.effectTag&nbsp;!=&nbsp;null&nbsp;?&nbsp;[fiber]&nbsp;:&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;parentEffects&nbsp;=&nbsp;fiber.parent.effects&nbsp;||&nbsp;[]</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;fiber.parent.effects&nbsp;=&nbsp;parentEffects.concat(childEffects,&nbsp;thisEffect)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;pendingCommit&nbsp;=&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>completeWork()</code>는 먼저 클래스 컴포넌트의 인스턴스와 관련된 fiber 에 대한 참조를 업데이트합니다. (솔직히 말해서, 여기 있을 필요는 없지만 어딘가에 있어야 합니다.)</p>
<p>그런 다음 <code>effects</code> 목록을 작성합니다. 이 목록에는 effectTag 가 있는 work-in-progress 서브 트리의 모든 fiber 들이 포함됩니다. (DELETION effectTag 를 가진 이전 하위 트리의 파이버도 포함). 이 아이디어는 effectTag 가 있는 모든 fiber 를 root <code>effects</code> 목록에 누적하는 것입니다.</p>
<p>마지막으로 fiber 에 부모(<code>parent</code>)가 없다면, work-in-progress 트리의 루트에 위치 해 있는것 입니다. 따라서 우리는 업데이트에 대한 모든 작업을 완료하고 모든 effects 를 수집했습니다. <code>workLoop()</code>이 <code>commitAllWork()</code>를 호출 할 수 있도록 <code>pendingCommit</code> 에 root 를 대입합니다.</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/ho_blog/static/fiber11-648b738f5f4d8d0d37a11a67bf1bcd76-108ba.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 21.428571428571427%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAkklEQVQI122OSw6EMAxDuf8REQuKqESL6AKmX2iYN1TsxovIcWQ73f1CRO5/OM+zlFJr9d4fxwFhTSlBOjxa62EYlmWZ5xmulLLW7vveEtOD67qYwfsqQphzjrUjeF3XcRz7vp+miRSmMYZbaw4hxBjpaQQF/+Yc/b9mUonglnMuL9AxoGDgCieOFV1y/mwbn3wBKM3m+MI+f7YAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="fiber11.png"
        title=""
        src="/ho_blog/static/fiber11-648b738f5f4d8d0d37a11a67bf1bcd76-fb8a0.png"
        srcset="/ho_blog/static/fiber11-648b738f5f4d8d0d37a11a67bf1bcd76-1a291.png 148w,
/ho_blog/static/fiber11-648b738f5f4d8d0d37a11a67bf1bcd76-2bc4a.png 295w,
/ho_blog/static/fiber11-648b738f5f4d8d0d37a11a67bf1bcd76-fb8a0.png 590w,
/ho_blog/static/fiber11-648b738f5f4d8d0d37a11a67bf1bcd76-108ba.png 700w"
        sizes="(max-width: 590px) 100vw, 590px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>이제 마지막으로 남은건 DOM 을 변경하는 것입니다.</p>
<pre class="editor editor-colors"><div class="line"><span class="text plain null-grammar"><span>function&nbsp;commitAllWork(fiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;fiber.effects.forEach(f&nbsp;=&gt;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;commitWork(f)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;})</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;fiber.stateNode._rootContainerFiber&nbsp;=&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;nextUnitOfWork&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;pendingCommit&nbsp;=&nbsp;null</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;commitWork(fiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(fiber.tag&nbsp;==&nbsp;HOST_ROOT)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;domParentFiber&nbsp;=&nbsp;fiber.parent</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(domParentFiber.tag&nbsp;==&nbsp;CLASS_COMPONENT)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;domParentFiber&nbsp;=&nbsp;domParentFiber.parent</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;const&nbsp;domParent&nbsp;=&nbsp;domParentFiber.stateNode</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(fiber.effectTag&nbsp;==&nbsp;PLACEMENT&nbsp;&amp;&amp;&nbsp;fiber.tag&nbsp;==&nbsp;HOST_COMPONENT)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;domParent.appendChild(fiber.stateNode)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(fiber.effectTag&nbsp;==&nbsp;UPDATE)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;updateDomProperties(fiber.stateNode,&nbsp;fiber.alternate.props,&nbsp;fiber.props)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(fiber.effectTag&nbsp;==&nbsp;DELETION)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;commitDeletion(fiber,&nbsp;domParent)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>function&nbsp;commitDeletion(fiber,&nbsp;domParent)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;let&nbsp;node&nbsp;=&nbsp;fiber</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(true)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node.tag&nbsp;==&nbsp;CLASS_COMPONENT)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.child</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;domParent.removeChild(node.stateNode)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(node&nbsp;!=&nbsp;fiber&nbsp;&amp;&amp;&nbsp;!node.sibling)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.parent</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node&nbsp;==&nbsp;fiber)&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;node.sibling</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p><code>commitAllWork()</code> 먼저 각각의 모든 루트 <code>effects</code> 를 순회하여 <code>commitWork()</code> 반복해서 호출합니다. <code>commitWork()</code>는 각 fiber 의 <code>effectTag</code> 를 검사합니다.</p>
<ul>
<li>
<p><code>PLACEMENT</code> 인 경우 우리는 부모 DOM 노드를 찾은 다음 단순히 fiber 의 stateNode 를 추가합니다.</p>
</li>
<li>
<p><code>UPDATE</code> 인 경우 stateNode 를 이전 props 및 새 props 와 함께 전달하고 <code>updateDomProperties()</code>가 업데이트 할 항목을 결정하도록 합니다.</p>
</li>
<li>
<p><code>DELETION</code> 이고 fiber 가 호스트 컴포넌트인 경우 간단합니다. 그저 <code>removeChild()</code>를 호출하면 됩니다. 그러나 fiber 가 클래스 컴포넌트인 경우 <code>removeChild()</code>를 호출하기 전에 fiber 하위 트리에서 모든 호스트 컴포넌트를 찾아서 제거해야 합니다.</p>
</li>
</ul>
<p>모든 effects 가 끝나면 <code>nextUnitOfWork</code> 및 <code>pendingCommit</code> 을 초기화 할 수 있습니다. work-in-progress 트리는 작업중인 트리가 아닌 이전 트리가 되므로 루트를 _rootContainerFiber 에 할당합니다. 이제 우리는 현재의 업데이트가 끝냈고 다음 업데이트를 시작할 준비가 되었습니다.</p></div><hr style="margin-bottom:1.53rem;" data-reactid="9"/><div style="display:flex;margin-bottom:3.825rem;" data-reactid="10"><img src="/ho_blog/static/img_profile.1f79e005.jpeg" alt="Merlin.ho" style="margin-right:0.765rem;margin-bottom:0;width:3.06rem;height:3.06rem;" data-reactid="11"/><p data-reactid="12"><!-- react-text: 13 -->Written by <!-- /react-text --><strong data-reactid="14">Merlin.ho</strong><!-- react-text: 15 --> who lives and works in Pangyo building useful things.<!-- /react-text --><!-- react-text: 16 --> <!-- /react-text --></p></div></div><span style="display:block;clear:both;" data-reactid="17"> </span></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-00a132d46dd380b9cb63.js","99219681209289":"component---node-modules-gatsby-plugin-offline-app-shell-js-5c4c5a0f7af9dc69d6d7.js","107818501498521":"component---src-templates-blog-post-js-dabe65ee189101b630a0.js","35783957827783":"component---src-pages-index-js-4a72a400e6141dde0d21.js","60335399758886":"path----557518bd178906f8d58a.js","210333531512890":"path---offline-plugin-app-shell-fallback-a0e39f21c11f6a62c5ab.js","140444808481594":"path---docker-depolyment-4012246536442f60159d.js","111898030062913":"path---call-stack-ae217c5d96088f3ccd78.js","67469829867878":"path---hello-monad-59e45b33826bee6342ec.js","163121481561693":"path---hello-web-server-50ce4db03e3201a76414.js","240236403038750":"path---maintainable-javascript-event-handling-08483da9a7c1874195de.js","275591574691347":"path---lazy-evaluation-b06a6cf4962e0032b9fb.js","78697077285144":"path---maintainable-javascript-user-error-throwing-2f9594d962f6c72f1e44.js","163591510377563":"path---maintainable-javascript-no-null-comparison-cd4e4ae619857122decb.js","219926873231408":"path---refactoring-complex-refactoring-3bde085886c272fceff0.js","122409595676540":"path---think-high-order-function-58f7199816abbe8ab707.js","105843449635648":"path---experience-monorepo-481c39ada3235001112a.js","174342234436027":"path---hello-middleware-214cfa12d70783762915.js","60702703624353":"path---hello-react-e0cd56e5890daca606f6.js","51191554927023":"path---javascript-basic-1-9a67a2cd34c9412b299b.js","73704410068446":"path---javascript-object-a5446c0327b623ee17b9.js","79996153856445":"path---refactoring-method-cleanup-46236c286e9dee8da3fa.js","257369935370228":"path---refactoring-moving-between-object-9e40449234c2cb6b787d.js","246346007348531":"path---tail-recursion-cb56656bef776961b80b.js","142221992286439":"path---ui-unit-testing-a749535a7628a8651417.js","88166365168691":"path---try-catch-786de2e0ecb3ac4f72aa.js","5023129853458":"path---value-and-reference-6083800bc1607839d93d.js","59645336058927":"path---hello-flow-f30a55513f3646cb48d1.js","90837107504198":"path---hello-oop-8753bd908c30244d5ee3.js","231909470762625":"path---refactoring-concise-conditionals-d2ab514478d45d06c674.js","58827738984857":"path---refactoring-organization-data-1-3cae99d84479a08a4086.js","177359372373161":"path---webpack-config-d646c3ec578c78b12b66.js","55049869895717":"path---hello-docker-05e42a31d1677fb4a2e0.js","160582500480188":"path---hello-webpack-b0122eda8ae66d76c639.js","23603272521549":"path---make-promise-dc2b0ce814f7e412d396.js","239272989053013":"path---refactoring-generalization-processing-e71d2e5e4b0e785fd2f5.js","122362222700994":"path---refactoring-5ee2d02ba04bdb575764.js","201965495218339":"path---refactoring-organization-data-2-6725e1fa3585396087cf.js","234343465206083":"path---sop-and-cors-dns-rebinding-0d28de5fe72d23bb7185.js","262138261438389":"path---hello-rxjs-3872b9c973e75356e524.js","71473981912016":"path---javascript-pattern-648c1f680f29c9828e5a.js","120945912393580":"path---refactoring-simplifying-method-calls-294a8dadb4d3828fd246.js","132591256042226":"path---hello-mobx-01735f8a0f592b5e0358.js","134631639062865":"path---build-react-8fe160cba69ecb4070e4.js","142629428675168":"path---index-cf2fab70390a644affba.js","114276838955818":"component---src-layouts-index-js-60e98b905b7a1c56256e.js"}/*]]>*/</script><script>
            
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'undefined', 'auto');
      }
      </script><script>/*<![CDATA[*/["/ho_blog/commons-241c3561f1c9cf4619a9.js","/ho_blog/app-00a132d46dd380b9cb63.js","/ho_blog/path---build-react-8fe160cba69ecb4070e4.js","/ho_blog/component---src-templates-blog-post-js-dabe65ee189101b630a0.js","/ho_blog/component---src-layouts-index-js-60e98b905b7a1c56256e.js"].forEach(function(s){document.write('<script src="'+s+'" defer></'+'script>')})/*]]>*/</script></body></html>